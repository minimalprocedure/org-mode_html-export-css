<!DOCTYPE html>
<html>
<head>
<title>Programmazione elementare in Ruby.</title>
<!-- 2014-11-02 dom 15:38 -->
<meta  charset="utf-8">
<meta  name="generator" content="Org-mode">
<meta  name="author" content="Massimo Maria Ghisalberti - pragmas.org">
<meta  name="description" content="Corso elementare di programmazione Ruby"
>
<meta  name="keywords" content="Ruby, programmazione">
<link rel="stylesheet" href="./org-minimalprocedure.css" type="text/css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Programmazione elementare in Ruby.</h1>
<nav id="table-of-contents">
<h2>Indice</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Premessa al corso di programmazione elementare</a>
<ul>
<li><a href="#sec-1-1">1.1. Ambienti liberi per l'insegnamento della programmazione a bambini e ragazzi.</a>
<ul>
<li><a href="#sec-1-1-1">1.1.1. Scratch</a></li>
<li><a href="#sec-1-1-2">1.1.2. Alice</a></li>
<li><a href="#sec-1-1-3">1.1.3. Hackety Hack</a></li>
<li><a href="#sec-1-1-4">1.1.4. KidsRuby</a></li>
<li><a href="#sec-1-1-5">1.1.5. Kojo</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-2">2. Perché Ruby direttamente e non un ambiente <i>facilitato</i>.</a></li>
<li><a href="#sec-3">3. Programmare in Ruby</a>
<ul>
<li><a href="#sec-3-1">3.1. Premessa</a></li>
<li><a href="#sec-3-2">3.2. cosa è Ruby</a></li>
<li><a href="#sec-3-3">3.3. Cosa serve</a></li>
<li><a href="#sec-3-4">3.4. Le basi</a>
<ul>
<li><a href="#sec-3-4-1">3.4.1. Iniziamo con i numeri e le stringhe</a></li>
<li><a href="#sec-3-4-2">3.4.2. Le variabili e gli assegnamenti</a></li>
<li><a href="#sec-3-4-3">3.4.3. Scriviamo un programma</a></li>
<li><a href="#sec-3-4-4">3.4.4. Riflessioni fino qui</a></li>
<li><a href="#sec-3-4-5">3.4.5. Confrontare le cose e decidere cosa fare</a></li>
<li><a href="#sec-3-4-6">3.4.6. Cicli, ripetere le cose da fare molte volte</a></li>
<li><a href="#sec-3-4-7">3.4.7. Scriviamo i nostri metodi, altrimenti a che serve?</a></li>
</ul>
</li>
<li><a href="#sec-3-5">3.5. Le cose serie</a>
<ul>
<li><a href="#sec-3-5-1">3.5.1. Raggruppiamo i metodi in moduli</a></li>
<li><a href="#sec-3-5-2">3.5.2. Le classi (non quelle della scuola, o forse si?)</a></li>
<li><a href="#sec-3-5-3">3.5.3. Blocks e Procs, che non è il Rock'n'Roll ma ci si avvicina.</a></li>
<li><a href="#sec-3-5-4">3.5.4. Il mondo esterno</a></li>
<li><a href="#sec-3-5-5">3.5.5. I dizionari</a></li>
<li><a href="#sec-3-5-6">3.5.6. Le finestre che si aprono o si chiudono se fa freddo.</a>
<ul>
<li><a href="#sec-3-5-6-1">3.5.6.1. Divagazioni sul tema</a></li>
<li><a href="#sec-3-5-6-2">3.5.6.2. Facciamole queste finestre, che ci siamo annoiati!</a>
<ul>
<li><a href="#sec-3-5-6-2-1">3.5.6.2.1. il problema</a></li>
<li><a href="#sec-3-5-6-2-2">3.5.6.2.2. Le scarpette rosse</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-3-6">3.6. Conclusioni</a></li>
</ul>
</li>
</ul>
</div>
</nav>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Premessa al corso di programmazione elementare</h2>
<div class="outline-text-2" id="text-1">
<p>
Il mondo moderno è immerso nella tecnologia.
Oggi sarebbe impensabile pensare ad una vita slegata dagli strumenti tecnologici che usiamo tutti i giorni, che siano semplici interruttori o automobili.
I computer oggi sono ubiquitari, che ce ne accorgiamo o no; sono nelle nostre lavatrici, nelle automobili, negli aerei, nei telefoni fino dal più semplice e non <i>smart</i>.
</p>

<p>
La popolazione è sostanzialmente divisa in <i>nativi</i> e <i>non nativi</i> digitali, persone che hanno potuto accedere al <i>computer</i> in età adulta o post-adolescenziale e persone che sono nate e si sono formate in piena rivoluzione informatica.
Gli approcci delle due fasce di popolazione sono sostanzialmente diversi: La prima generalmente possiede una certa diffidenza <i>naturale</i> verso il mezzo informatico, mentre la seconda lo usa con naturalezza e propensione.
</p>

<p>
Il computer è un superbo mezzo di comunicazione, di lavoro e svago; sempre più potente ed inserito nella vita normale. È un mezzo, per cui né <i>buono</i> né <i>cattivo</i>, dipende solo dall'uso che ne viene fatto.
Il <i>nativo digitale</i> a causa della sua naturalezza all'uso del mezzo informatico è oggi un soggetto potenzialmente a rischio. La maggior parte di noi è consapevole, per esempio, dell'approccio passivo alla televisione; della comunicazione a senso unico che porta e di come in taluni casi questa informazione possa essere manipolata e non corretta. Nessuno di noi però, è ancora propriamente consapevole dei pericoli insiti nell'uso acritico e non corretto dei nostri piccoli ed ubiquitari computer.
</p>

<p>
Abbiamo telefoni intelligenti, tablet o notebook che portiamo ovunque andiamo.
I nostri figli li hanno, mini e microcomputer perennemente connessi ad Internet, dove possono fruire più o meno liberamente dei contenuti più disparati.
Vietare non è la soluzione, impedirgli di usarli non è la soluzione ma solo un tampone temporaneo che presto imparerà a scavalcare.
Si dovrebbe insegnare ai nostri figli, <i>nativi digitali</i>, l'approccio consapevole ed informato. <br >
</p>

<p>
Gli approcci agli insegnamenti informatici vanno rivisti e va rivista l'età in cui iniziare.
Le lezioni di <i>avviamento al computer</i> che venivano e vengono utilizzati oggi non sono più adatti per i <i>nativi digitali</i>. Accendere un computer e lanciare una applicazione per i nostri figli è naturale come per noi accedere il televisore e cambiare canale. Usare un gioco, che è un software, è naturale per loro.
Passivamente naturale, il mito della interattività è solo un percorso preordinato tra tanti progettati a monte dell'utente e si è passivi nell'illusione di non esserlo.
Bisogna passare dalla semplice visione strumentale e <i>alfabetizzazione informatica</i> alla fase di acquisizione delle <i>competenze digitali</i>. <br >
</p>

<p>
Per questo motivo, si dovrebbe insegnare la <i>programmazione dei computer</i> ai bambini in età scolare.
Non per creare una <i>generazione di programmatori</i> (come mi si è accusato), ovviamente, ma per rendere delle persone consapevoli ed attive di fronte al mezzo informatico.
</p>

<p>
Programmare un computer è affrontare e risolvere problemi, <i>problem posing and solving</i>, è imparare a ordinare i pensieri per poter realizzare le idee. 
L'approccio può essere multidisciplinare e il metodo applicabile in molti campi e non necessariamente informatici. Lo studio della <i>programmazione</i> è quindi, oltre alla sua mera applicazione, una formidabile palestra di logica che guida il ragazzo attraverso un percorso che passa per l'analisi, la scomposizione dei problemi, la verifica dei risultati e l'organizzazione del pensiero.
</p>

<p>
Imparare a programmare, insegna la collaborazione e la condivisione (se insegnata nella maniera adeguata) tramite un processo di <i>trial and error</i> e permette allo studente di esprimersi in molti modi. L'approccio produttivo ed anche ludico, potrebbe permettere di attirare e coinvolgere studenti problematici e creare interesse. <br >
</p>

<p>
<i>Quando i bambini creano un progetto come questo, imparano anche a programmare, ma, cosa ancora più importante, programmano per imparare. Perché imparando a programmare, imparano mille altre cose, aprendo nuove opportunità di apprendimento. Ripeto, è utile fare un'analogia con la lettura e la scrittura. Quando si impara a leggere e scrivere, si aprono nuove opportunità per imparare molte altre cose. Quando si impara a leggere, allora si potrà anche leggere per imparare. E imparare a programmare è la stessa cosa. Se si impara a programmare, allora si potrà anche programmare per imparare. Ora, alcune cose che si imparano sono piuttosto ovvie. Si impara qualcosa di più su come funzionano i computer. Ma questo è solamente il punto di partenza. Quando si impara a programmare, si apre la possibilità di imparare molte altre cose.</i> <br >
</p>

<p>
<i>As kids are creating projects like this, <b>they're learning to code, but even more importantly, they're coding to learn</b>. Because as they learn to code, it enables them to learn many other things, opens up many new opportunities for learning. Again, it's useful to make an analogy to reading and writing. When you learn to read and write, it opens up opportunities for you to learn so many other things. When you learn to read, you can then read to learn. And it's the same thing with coding. If you learn to code, you can code to learn. Now some of the things you can learn are sort of obvious. You learn more about how computers work. But that's just where it starts. When you learn to code, it opens up for you to learn many other things.</i> <br >
</p>

<p>
<b>Mitch Resnick</b> (<a href="http://www.ted.com/talks/mitch_resnick_let_s_teach_kids_to_code/transcript">http://www.ted.com/talks/mitch_resnick_let_s_teach_kids_to_code/transcript</a>) <br >
</p>

<p>
È nel contempo importante, insegnare come l'approccio al software ed alla sua produzione debba essere <i>morale</i> spingendo lo studente verso il concetto di <i>Open Source</i>, spostando il valore dal prodotto in sé al produttore (il programmatore); combattendo la visione monopolistica delle grandi <i>software house</i> o <i>software service</i> verso un approccio sostanziale alle tipologie software (anche solo nel rispetto delle direttive ministeriali in materia di software da utilizzare nelle pubbliche amministrazioni). <br >
</p>

<p>
Non va dimenticato inoltre, all'atto pratico, come in futuro la richiesta di programmatori diventerà altissima e quindi si potrebbe fornire agli studenti uno strumento in più.
Esistono numerose esperienze, specialmente negli U.S.A., di insegnamento della programmazione a bambini in età scolare (k-12); mentre per l'Europa si potrebbero citare le esperienze fatte in UK ed Estonia.
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Ambienti liberi per l'insegnamento della programmazione a bambini e ragazzi.</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Per avvicinare gli studenti alla programmazione informatica esistono già numerosi strumenti con un approccio più o meno <i>visuale</i>. In questa sede si prenderanno in considerazione solo strumenti Open Source per i motivi espressi sopra.
</p>
</div>

<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1"><span class="section-number-4">1.1.1</span> Scratch</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
È una piattaforma sviluppata al MIT (Massachusetts Institute of Technology) nel <i>Lifelong Kindergarten Group</i> (<a href="http://scratch.mit.edu/">http://scratch.mit.edu/</a>) e progettata specificatamente per bambini di età scolare e prescolare. L'approccio è totalmente visuale con blocchi logici colorati e di facile comprensione. È adatto per insegnare la strutturazione del flusso delle istruzioni rendendola facilmente identificabile con risultati rapidi e non frustranti per il bambino.
Ne esistono attualmente due versioni una scritta in <i>Smalltalk</i> (<a href="http://scratch.mit.edu/scratch_1.4">http://scratch.mit.edu/scratch_1.4</a>), quella originale, mentre una seconda fruibile online e scritta in <i>ActionScript</i> (<a href="http://scratch.mit.edu/projects/editor/?tip_bar=getStarted">http://scratch.mit.edu/projects/editor/?tip_bar=getStarted</a>) o scaricabile (<a href="http://scratch.mit.edu/scratch2download/">http://scratch.mit.edu/scratch2download/</a>).
</p>

<p>
Scratch ha dato vita a numerosi progetti simili, come per esempio AppInventor (<a href="http://appinventor.mit.edu/explore/">http://appinventor.mit.edu/explore/</a>), Blockly (<a href="https://code.google.com/p/blockly/">https://code.google.com/p/blockly/</a>), Stencyl (<a href="http://www.stencyl.com/">http://www.stencyl.com/</a>).
</p>
</div>
</div>

<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2"><span class="section-number-4">1.1.2</span> Alice</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
Alice è un ambiente visuale per la creazione di mondi virtuali in 3D ed è il risultato di un progetto della Carnegie Mellon University di Pittsburgh (Pennsylvania).
</p>
</div>
</div>

<div id="outline-container-sec-1-1-3" class="outline-4">
<h4 id="sec-1-1-3"><span class="section-number-4">1.1.3</span> Hackety Hack</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
È un piccolo ambiente (<a href="http://hackety.com/">http://hackety.com/</a>) per l'insegnamento alla programmazione nel linguaggio Ruby (<a href="https://www.ruby-lang.org/it/">https://www.ruby-lang.org/it/</a>). Il linguaggio di programmazione Ruby è nato nel 1992 scritto da Yukihiro Matsumoto. Oggi è un linguaggio molto popolare (anche se non popolarissimo in Italia). Le sue peculiari caratteristiche di immediatezza nell'utilizzo ne fanno un buon candidato per l'insegnamento anche a bambini in età scolare.
</p>
</div>
</div>

<div id="outline-container-sec-1-1-4" class="outline-4">
<h4 id="sec-1-1-4"><span class="section-number-4">1.1.4</span> KidsRuby</h4>
<div class="outline-text-4" id="text-1-1-4">
<p>
KidsRuby (<a href="http://www.kidsruby.com/">http://www.kidsruby.com/</a>) è una evoluzione di Hackety Hack. Come il suo ispiratore usa Ruby come linguaggio.
</p>
</div>
</div>

<div id="outline-container-sec-1-1-5" class="outline-4">
<h4 id="sec-1-1-5"><span class="section-number-4">1.1.5</span> Kojo</h4>
<div class="outline-text-4" id="text-1-1-5">
<p>
Kojo è sviluppato da Lalit Pant (Himjyoti school, Dehradun - India) ed è utilizzato in varie scuole indiane, statunitensi, inglesi e svedesi.
L'approccio usato nella piattaforma Kojo (<a href="http://www.kogics.net/kojo">http://www.kogics.net/kojo</a>) è più ampio dei precedenti. Può essere rivolto a più livelli di apprendimento ed è dotato di parti specifiche, per esempio per la sperimentazione in ambito matematico con un laboratorio basato su GeoGebra (<a href="http://www.geogebra.org/cms/it/">http://www.geogebra.org/cms/it/</a>). Il linguaggio utilizzato è Scala (<a href="http://www.scala-lang.org/">http://www.scala-lang.org/</a>).
Scala è un linguaggio estremamente potente e multiparadigma (Orientato agli oggetti, funzionale) che può essere utilizzato a vari livelli, sufficientemente semplice da poter essere insegnato in età scolare (dalla classe 4° primaria). La sua caratteristica di linguaggio funzionale lo fa particolarmente utile nella risoluzione di problemi matematici. I linguaggi funzionali sono una modalità di programmazione in forte ascesa in questi ultimi anni e sicuramente lo saranno anche per i prossimi.
</p>
</div>
</div>
</div>
</div>



<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Perché Ruby direttamente e non un ambiente <i>facilitato</i>.</h2>
<div class="outline-text-2" id="text-2">
<p>
È una scelta difficile non partire con un ambiente facilitato, come Scratch per esempio. Scratch è sicuramente un ottimo ambiente per l'insegnamento della logica di programmazione ai bambini. Scratch è colorato e simpatico, ha una mascotte (un gatto) e permette velocemente di ottenere risultati con grafica e suoni, sembra un gioco. Il suo sembrare <i>troppo</i> un gioco tende però a fuorviare i bambini dallo scopo primario.
I nostri ragazzi non hanno una mentalità <i>anglosassone</i> e sono meno organizzati e disciplinati degli <i>anglosassoni</i>, il che rende ambienti <i>troppo ludici</i> dispersivi. I bambini <i>nativi digitali</i> tenderanno a giocare troppo con gli strumenti; potendo, per esempio, facilmente disegnare <i>sprite</i> (oggetti grafici) e farli muovere manualmente.
</p>

<p>
Scopo di un corso di programmazione è anche aumentare la percezione del computer stesso, come un insieme di hardware e sistema operativo con software applicativo. L'utente dovrebbe distinguere ed utilizzare le varie parti e capirne le relazioni, altrimenti si potrebbe incorrere nello stesso errore: il nascondere parti sostanziali; che renderà l'utilizzo dello strumento informatico più o meno passivo.
</p>

<p>
Inoltre, questi ambienti sono troppo orientati ad una <i>logica di tipo imperativo</i> e legati ad un <i>diagramma di flusso</i> di, ormai, vecchia concezione. Un problema tipico dei programmatori di computer è il cambio di <i>paradigma</i> come molti studi ed esperienze dimostrano. Cambiare stile di programmazione è difficile e quindi introdurre i giovani verso linguaggi multiparadigma potrà solo renderli più flessibili in futuro. 
</p>
</div>
</div>


<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Programmare in Ruby</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> Premessa</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Questo sarà un piccolo corso per l'avvio alla programmazione in Ruby, un linguaggio estremamente semplice e divertente ma non per questo banale.
Ruby ha in sé tutte le caratteristiche per essere un ottimo <i>linguaggio di programmazione multiparadigma</i> ed essere adatto per l'insegnamento delle basi della programmazione dei computer moderna.
</p>

<p>
<b><i>Ruby è divertente</i></b>.
</p>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> cosa è Ruby</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Questo è copiato semplicemente dal sito web di Ruby:
</p>

<p>
<i>Ruby è un linguaggio di equilibrio e armonia. Il suo creatore, Yukihiro “Matz” Matsumoto, ha fuso insieme parti dei suoi linguaggi di programmazione preferiti (Perl, Smalltalk, Eiffel, Ada e Lisp) per creare un nuovo linguaggio in grado di bilanciare programmazione funzionale con programmazione imperativa.</i>
</p>

<p>
<i>Lui stesso ha detto più volte che sta continuamente "provando a rendere Ruby naturale, non semplice", in un modo che rispecchia la vita.</i>
</p>

<p>
<i>Chiarificando questo concetto, Matz aggiunge:</i>
</p>

<p>
<i>Ruby è apparentemente semplice, ma al suo interno è molto complesso, proprio come il corpo umano.</i>
</p>
</div>
</div>


<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> Cosa serve</h3>
<div class="outline-text-3" id="text-3-3">
<p>
Ruby è un linguaggio di programmazione.
Un linguaggio di programmazione è, come un linguaggio naturale, un insieme di regole e convenzioni per permetterci di parlare con i computer.
I computer sono macchine di calcolo <i>stupide</i> e devono essere istruite.
Per utilizzare un linguaggio di programmazione serve un <i>software</i>, un programma per computer. È il problema del <i>cane che si morde la coda</i>, per scrivere un <i>software</i> ci vuole un altro <i>software</i>.
Quindi per usare Ruby dobbiamo installare l'<i>interprete</i> <b>Ruby</b>.
Qui potremmo entrare in una distinzione inizialmente un po' difficile: cosa è un <i>interprete</i> e cosa è un <i>compilatore</i>. La differenza oggi è molto <i>labile</i>, ma comunque in generale:
</p>

<ul class="org-ul">
<li>l'<i>interprete</i> è un software che legge, interpreta direttamente ed esegue un programma scritto in un linguaggio.
</li>
<li>un <i>compilatore</i> è un software che legge, interpreta e trasforma in dati binari un programma scritto in un linguaggio, salvando sul disco un file detto <i>eseguibile</i> che potrà essere lanciato (<i>eseguito</i>) direttamente.
</li>
</ul>


<p>
Quindi abbiamo bisogno dell'<i>interprete</i> Ruby.
</p>

<p>
Questo software è <i>multipiattaforma</i>, il che vuol dire che può funzionare (più o meno bene) su molti sistemi operativi.
</p>

<p>
Cosa è un sistema operativo:
</p>

<ul class="org-ul">
<li>Un sistema operativo è il <i>software di base</i> del computer, senza esso non si potrebbe utilizzare.
</li>
</ul>

<p>
Di sistemi operativi ne esistono molti. Forse il più conosciuto è Microsoft Windows<sup>(tm)</sup> ma non è il solo. Esistono le distribuzioni Linux, per esempio, il MacOSX<sup>(tm)</sup> o l'Android che avete probabilmente nei tablet o telefoni. Ne esistono davvero molti, a pagamento o gratuiti e per molteplici utilizzi.
</p>

<p>
Ruby funziona in molti di essi. 
</p>

<p>
Ruby ha un sito web dedicato: <a href="https://www.ruby-lang.org">https://www.ruby-lang.org</a>, dove ci sono tantissime informazioni su di esso, dalla sua storia alla documentazione e per finire al software stesso e le indicazioni su come installarlo (cioè metterlo) nel computer che possedete.
L'interprete può essere prelevato come codice sorgente, ha una licenza <i>Open Source</i>, compilarlo ed installarlo; altrimenti se ne può utilizzare una versione già pronta per il sistema operativo che volete.
Come si può vedere dalle pagine web relative: <a href="https://www.ruby-lang.org/it/downloads/">https://www.ruby-lang.org/it/downloads/</a> e <a href="https://www.ruby-lang.org/it/installation/">https://www.ruby-lang.org/it/installation/</a>, ci sono varie <i>implementazioni</i> dell'<i>interprete</i>.
</p>

<p>
Installate o fatevi installare la più adatta.
</p>

<p>
Vi dovete anche procurare un <i>editor di testo</i> per programmatori. È un più o meno semplice programma per scrivere, diverso dal <i>word processor</i> che usate per scrivere. Spesso questi <i>editor</i> hanno la possibilità di evidenziare la <i>sintassi</i> (le parole) del linguaggio in colori diversi, permettendo di poter trovare le parti del programma che state scrivendo a <i>colpo d'occhio</i> e limitandone anche gli errori di battitura.
</p>

<p>
Qui: <a href="https://www.ruby-lang.org/it/documentation/">https://www.ruby-lang.org/it/documentation/</a>, ne trovate una lista in fondo alla pagina, sappiate comunque che esistono tantissimi <i>editor</i> per programmatori che lì non sono elencati. Alcuni sono a pagamento ed altri sono gratuiti, <i>open Source</i> o no.
</p>

<p>
Ruby è un linguaggio diffuso oggi, quindi un qualunque editor per programmatori avrà una evidenziazione colorata per la sua sintassi.
</p>
</div>
</div>


<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> Le basi</h3>
<div class="outline-text-3" id="text-3-4">
<p>
In questo capitolo vedremo la <i>base</i> della programmazione in Ruby, alcuni elementi chiave e tipi di dati più diffusi.
</p>
</div>

<div id="outline-container-sec-3-4-1" class="outline-4">
<h4 id="sec-3-4-1"><span class="section-number-4">3.4.1</span> Iniziamo con i numeri e le stringhe</h4>
<div class="outline-text-4" id="text-3-4-1">
<p>
Ruby ha anche un <i>REPL</i>, <i>Read Eval Print Loop</i>, che a parte la parola difficile sta a significare che si possono mandare direttamente comandi all'interprete.
Nella distribuzione di Ruby c'è un programma (scritto in Ruby) che si chiama <i>irb (interactive ruby)</i>. Per lanciarlo dovete saper usare un minimo un terminale dei comandi. Un terminale dei comandi è, nel vostro sistema operativo moderno, una finestra in cui lo sfondo è spesso nero con un cursore che lampeggia. Ci potete scrivere dentro e mandare comandi al sistema operativo.
</p>

<p>
Cercate nei vai menù del sistema qualcosa del tipo: <i>prompt dei comandi</i> o <i>terminale</i>&#x2026;
</p>

<p>
Lanciata la <i>console dei comandi</i> ci scrivete dentro <i>irb</i> e premete invio.
</p>

<div class="org-src-container">

<pre class="src src-ruby">irb(main)<span class="org-constant">:001</span>:0&gt;
</pre>
</div>

<p>
A questo punto potete inviare comandi all'interprete e confermare premendo invio.
</p>

<div class="org-src-container">

<pre class="src src-ruby">irb(main)<span class="org-constant">:001</span>:0&gt;  1 + 2
=&gt; 3
irb(main)<span class="org-constant">:002</span>:0&gt;
</pre>
</div>

<p>
Se scrivete 1 + 2 avrete il risultato. Ruby è anche una <i>calcolatrice</i>.
Provate a fare dei calcoli con le operazioni che conoscete, saranno rispettate le regole matematiche di precedenza degli operatori che vi sono state insegnate: 
</p>

<ul class="org-ul">
<li><b>+</b>, addizione
</li>
<li><b>-</b>, sottrazione
</li>
<li><b>*</b>, moltiplicazione
</li>
<li><b>/</b>, divisione
</li>
<li><b>%</b>, modulo
</li>
<li><b>**</b>, esponente
</li>
</ul>

<p>
Bisogna stare attenti alla divisione, come la maggior parte dei linguaggi di programmazione. Se per esempio:
</p>

<div class="org-src-container">

<pre class="src src-ruby">irb(main)<span class="org-constant">:013</span>:0&gt; 10 / 7
=&gt; 1
irb(main)<span class="org-constant">:014</span>:0&gt;
</pre>
</div>

<p>
potete vedere come il risultato è 1. Per trovare il resto della divisione dovete effettuare una operazione di <i>modulo</i> che vi restituisce il resto:
</p>

<div class="org-src-container">

<pre class="src src-ruby">irb(main)<span class="org-constant">:014</span>:0&gt; 10 % 7
=&gt; 3
irb(main)<span class="org-constant">:015</span>:0&gt;
</pre>
</div>

<p>
che ovviamente è 3. Quindi l'operatore <b>/</b> nel caso in cui i due numeri (operandi) siano di tipo <i>intero</i> eseguirà una divisione intera, troncando la parte decimale.
</p>

<p>
Per avere la parte decimale si deve fare così:
</p>

<div class="org-src-container">

<pre class="src src-ruby">irb(main)<span class="org-constant">:015</span>:0&gt; 10 / 7.0
=&gt; 1.4285714285714286
irb(main)<span class="org-constant">:016</span>:0&gt;
</pre>
</div>

<p>
e cioè scrivere almeno uno degli operandi nella forma cosiddetta <i>a virgola mobile o flottante</i> (float). L'interprete allora saprà che dovrà eseguire una divisione non intera.
Nel caso in cui facciate una operazione di modulo con almeno un operando di tipo <i>float</i>
</p>

<div class="org-src-container">

<pre class="src src-ruby">irb(main)<span class="org-constant">:016</span>:0&gt; 10 % 7.0
=&gt; 3.0
irb(main)<span class="org-constant">:017</span>:0&gt;
</pre>
</div>

<p>
il risultato sarà come per la divisione intera ma con il tipo del risultato in virgola (<i>float</i>).
Ruby supporta le parentesi tonde che possono essere annidate (scritte le une dentro le altre) liberamente.
Come per gli altri linguaggi di programmazione le parentesi graffe e quadre sono usate per altri scopi e non quello di alterare le precedenze degli operatori o raggruppare i calcoli.
</p>

<div class="org-src-container">

<pre class="src src-ruby">irb(main)<span class="org-constant">:017</span>:0&gt; (2 + 3) * 2
=&gt; 10
irb(main)<span class="org-constant">:018</span>:0&gt;
</pre>
</div>

<p>
I linguaggi di programmazione sono in grado di manipolare numerosi tipi di dati e fino a qui ne abbiamo visti due:
</p>

<ul class="org-ul">
<li>numeri interi (<i>integer</i>)
</li>
<li>numeri in virgola mobile (<i>float</i>)
</li>
</ul>

<p>
questi sono chiamati in Ruby <i>Fixnum</i> e <i>Float</i> rispettivamente.
</p>

<p>
Per esempio:
</p>

<div class="org-src-container">

<pre class="src src-ruby">irb(main)<span class="org-constant">:019</span>:0&gt; 1.class
=&gt; <span class="org-type">Fixnum</span>
irb(main)<span class="org-constant">:020</span>:0&gt; 1.0.class
=&gt; <span class="org-type">Float</span>
irb(main)<span class="org-constant">:021</span>:0&gt;
</pre>
</div>

<p>
Vedremo in seguito cosa significa <i>1.class</i> e <i>1.0.class</i>, per adesso lasciamola come una cosa <i>magica</i> di Ruby: la possibilità di sapere quando serve il tipo di un certo dato (la <i>riflessione</i>). <br >
</p>

<p>
Un tipo di dato importantissimo in cui Ruby eccelle sono le stringhe (<i>String</i>).
Le stringhe sono una sequenza di caratteri, un testo insomma, una dietro l'altra compresi gli spazi ed i vari segni di punteggiatura.
</p>

<div class="org-src-container">

<pre class="src src-ruby">irb(main)<span class="org-constant">:021</span>:0&gt; <span class="org-string">"ciao mondo"</span>
=&gt; <span class="org-string">"ciao mondo"</span>
irb(main)<span class="org-constant">:022</span>:0&gt; <span class="org-string">'ciao modo'</span>
=&gt; <span class="org-string">"ciao modo"</span>
irb(main)<span class="org-constant">:023</span>:0&gt;
</pre>
</div>

<p>
Come potete vedere si possono usare sia le virgolette singole che quelle doppie. In questo caso non c'è differenza ma in altri sì e vedremo in seguito.
Le stringhe come i numeri possono essere sommate (<i>concatenate</i>):
</p>

<div class="org-src-container">

<pre class="src src-ruby">irb(main)<span class="org-constant">:024</span>:0&gt; <span class="org-string">"ciao"</span> + <span class="org-string">"mondo"</span>
=&gt; <span class="org-string">"ciaomondo"</span>
irb(main)<span class="org-constant">:025</span>:0&gt;
</pre>
</div>

<p>
ma non sottratte (almeno non così):
</p>

<div class="org-src-container">

<pre class="src src-ruby">irb(main)<span class="org-constant">:025</span>:0&gt; <span class="org-string">"ciao"</span> - <span class="org-string">"mondo"</span>
<span class="org-type">NoMethodError</span>: undefined method <span class="org-string">`-' for "ciao":String</span>
<span class="org-string">        from (irb):25</span>
<span class="org-string">        from /home/nissl/bin/ruby-2.1/bin/irb:11:in `</span>&lt;main&gt;<span class="org-string">'</span>
<span class="org-string">irb(main):026:0&gt;</span>
</pre>
</div>

<p>
Come vedete l'interprete ha dato un errore e si è fermato comunicandolo. In questa maniera possiamo sapere dove è l'errore e che tipo di errore è.
</p>

<p>
Le stringhe possono però essere moltiplicate per un numero ma non per un'altra stringa:
</p>

<div class="org-src-container">

<pre class="src src-ruby">irb(main)<span class="org-constant">:028</span>:0&gt; <span class="org-string">'pippo'</span> * 5
=&gt; <span class="org-string">"pippopippopippopippopippo"</span>
irb(main)<span class="org-constant">:029</span>:0&gt; 

irb(main)<span class="org-constant">:029</span>:0&gt; <span class="org-string">'pippo'</span> * <span class="org-string">'pippo'</span>
<span class="org-type">TypeError</span>: no implicit conversion of <span class="org-type">String</span> into <span class="org-type">Integer</span>
        from (irb)<span class="org-constant">:29</span>:in <span class="org-string">`*'</span>
<span class="org-string">        from (irb):29</span>
<span class="org-string">        from /home/nissl/bin/ruby-2.1/bin/irb:11:in `</span>&lt;main&gt;<span class="org-string">'</span>
<span class="org-string">irb(main):030:0&gt;</span>
</pre>
</div>

<p>
In questo esempio ho moltiplicato una stringa per un numero e sommata ad un'altra:
</p>

<div class="org-src-container">

<pre class="src src-ruby">irb(main)<span class="org-constant">:031</span>:0&gt; <span class="org-string">"pippo"</span> * 5 + <span class="org-string">"pluto"</span>
=&gt; <span class="org-string">"pippopippopippopippopippopluto"</span>
irb(main)<span class="org-constant">:032</span>:0&gt;
</pre>
</div>

<p>
Come potete vedere, le regole di precedenza sono state applicate: prima la moltiplicazione e poi la somma.
Nelle stringhe è possibile fare degli errori strani.
</p>

<p>
Guardate questa:
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-string">'pippo &#232; andato dall'</span>altra parte<span class="org-string">'</span>
</pre>
</div>

<p>
Questo è un errore. Come potete vedere la stringa inizia con una virgoletta singola (<i>apice singolo</i>) e termina con una virgoletta singola. Dove termina però? La colorazione della sintassi può aiutare a capire.
Per l'interprete la stringa termina dopo la parola <i>dall</i>. Il resto non è nella stringa. Per superare problemi come questo ci sono due modi principali:
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-string">'pippo &#232; andato dall\'altra parte'</span>
<span class="org-string">"pippo &#232; andato dall'altra parte"</span>
</pre>
</div>

<p>
Ho usato nella prima riga il carattere <b>\</b> (<i>escape</i>) che dice a Ruby di trattare il carattere che subito lo segue come un carattere della stringa e non come un terminatore della stessa.
Nel secondo caso, ho racchiuso la stringa tra virgolette doppie (<i>apice doppio</i>) e quindi ho potuto usare l'apice singolo liberamente.
</p>

<p>
Ora che ci siamo va capita bene la differenza tra numeri e stringhe:
</p>

<ul class="org-ul">
<li>25 è un numero
</li>
<li>'25' è una stringa
</li>
<li>"25" è una stringa
</li>
<li>'25 * 25' è una stringa e non una operazione
</li>
<li>25 * 25 è una moltiplicazione tra due numeri
</li>
<li>"pippo" * 5 va bene e verrà ripetuta la parola <i>pippo</i> per cinque volte
</li>
<li>5 * "pippo" non va bene perché significa <i>pippo volte il numero 5</i>.
</li>
</ul>

<p>
Provate tutte le possibili varianti che vi vengono in mente.
</p>
</div>
</div>

<div id="outline-container-sec-3-4-2" class="outline-4">
<h4 id="sec-3-4-2"><span class="section-number-4">3.4.2</span> Le variabili e gli assegnamenti</h4>
<div class="outline-text-4" id="text-3-4-2">
<p>
Ogni linguaggio d programmazione che si rispetti, ci permette di calcolare cose che non sappiamo <i>a priori</i>, altrimenti non servirebbero a niente. Fino ad adesso avete visto come utilizzare dei valori, ora vediamo come creare valori e recuperarli per quando ci servono.
</p>

<p>
Le <i>variabili</i> sono come delle scatole dove mettete delle cose e l'<i>assegnamento</i> è l'azione del mettercele dentro. Direi che è semplice.
</p>

<div class="org-src-container">

<pre class="src src-ruby">numero_delle_pere = 12
numero_delle_pere_vendute = 5
</pre>
</div>

<p>
Ho messo nella <i>variabile</i> <b>numero_delle_pere</b> la quantità di pere del contadino prima di andare al mercato. Al mercato il contadino fa il conto e mette nella <i>variabile</i> <b>numero_delle_pere_vendute</b> le pere che ha venduto e poi:
</p>

<div class="org-src-container">

<pre class="src src-ruby">numero_delle_pere_rimaste = numero_delle_pere - numero_delle_pere_vendute
</pre>
</div>

<p>
Il contadino ora sa che la <i>variabile</i> <b>numero_delle_pere_rimaste</b> contiene il numero 7.
</p>

<div class="org-src-container">

<pre class="src src-ruby">irb(main)<span class="org-constant">:045</span>:0&gt; numero_delle_pere = 12
=&gt; 12
irb(main)<span class="org-constant">:046</span>:0&gt; numero_delle_pere_vendute = 5
=&gt; 5
irb(main)<span class="org-constant">:047</span>:0&gt; numero_delle_per_rimaste = numero_delle_pere - numero_delle_pere_vendute
=&gt; 7
irb(main)<span class="org-constant">:048</span>:0&gt;
</pre>
</div>

<p>
Possiamo mettere dentro la nostra <i>scatola</i> quello che vogliamo. La comodità è che così noi ricordiamo più facilmente il nome piuttosto che il numero contenuto. È come quando vogliamo telefonare alla <i>mamma</i>, basta col nostro telefono scrivere <i>mamma</i> o dire <i>mamma</i>, il telefono saprà il numero. <br >
</p>

<p>
Possiamo fare con le <i>variabili</i> quello che facciamo con i valori: moltiplicarle, dividerle, sommarle o sottrarle&#x2026; e tante altre cose che vedremo.
</p>
</div>
</div>

<div id="outline-container-sec-3-4-3" class="outline-4">
<h4 id="sec-3-4-3"><span class="section-number-4">3.4.3</span> Scriviamo un programma</h4>
<div class="outline-text-4" id="text-3-4-3">
<p>
Fino ad adesso abbiamo usato per fare gli esperimenti il <i>REPL</i>. Adesso scriveremo un programma. <br >
Lanciate l'editor di testo e create un nuovo file. Sarete davanti ad un programma che vi permetterà di scrivere.
</p>

<p>
Abbiamo un problema: <br >
</p>

<p>
<i>Ci sono dieci bambini che devono portare delle pere ad una festa, ognuno ha 3 pere. Tre di questi bambini ne mangiano due ciascuno. Quante pere arriveranno alla festa.</i> <br >
</p>

<p>
Scrivete nel vostro <i>editor di testo</i>. <br >
</p>

<p>
Questi sono i dati:
</p>
<div class="org-src-container">

<pre class="src src-ruby">bambini = 10
pere_per_bambino = 3
bambini_che_hanno_mangiato_le_pere = 3
pere_mangiate_per_bambino = 2
</pre>
</div>

<p>
Ora un po' di calcoli: 
</p>

<div class="org-src-container">

<pre class="src src-ruby">pere_totali = bambini * pere_per_bambino
pere_mangiate = bambini_che_hanno_mangiato_le_pere * pere_mangiate_per_bambino
pere_arrivate_alla_festa = pere_totali - pere_mangiate
</pre>
</div>

<p>
Aggiungete poi questo:
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-builtin">puts</span> <span class="org-string">"Alla festa sono arrivate:"</span>
<span class="org-builtin">puts</span> pere_arrivate_alla_festa
<span class="org-builtin">puts</span> <span class="org-string">"pere"</span>
</pre>
</div>

<p>
Ora potete salvare il file come <i>pere.rb</i>
</p>

<p>
Il vostro programma completo sarà questo:
</p>

<div class="org-src-container">

<pre class="src src-ruby">bambini = 10
pere_per_bambino = 3
bambini_che_hanno_mangiato_le_pere = 3
pere_mangiate_per_bambino = 2

pere_totali = bambini * pere_per_bambino
pere_mangiate = bambini_che_hanno_mangiato_le_pere * pere_mangiate_per_bambino
pere_arrivate_alla_festa = pere_totali - pere_mangiate

<span class="org-builtin">puts</span> <span class="org-string">"Alla festa sono arrivate:"</span>
<span class="org-builtin">puts</span> pere_arrivate_alla_festa
<span class="org-builtin">puts</span> <span class="org-string">"pere"</span>
</pre>
</div>

<p>
Avete scritto un programma per risolvere il problema delle pere. Ora dovete farlo funzionare.
Ritorniamo al <i>terminale</i> di prima e nella cartella dove avete salvato il file scrivete:
</p>

<div class="org-src-container">

<pre class="src src-sh">ruby pere.rb
</pre>
</div>

<p>
Il file che contiene il programma sarà caricato da ruby ed eseguito. Se tutto è andato bene avrete avuto questo:
</p>

<div class="org-src-container">

<pre class="src src-sh">&#10140;  source  ruby pere.rb 
Alla festa sono arrivate:
24
pere
&#10140;  source
</pre>
</div>

<p>
Complimenti! <br >
</p>

<p>
Certo non è proprio bello, il risultato lo abbiamo su tre righe, non sarebbe meglio avere: <i>Alla festa sono arrivate 24 pere</i>?
Direi di si. <br >
Allora facciamo in questo modo:
</p>

<div class="org-src-container">

<pre class="src src-ruby">bambini = 10
pere_per_bambino = 3
bambini_che_hanno_mangiato_le_pere = 3
pere_mangiate_per_bambino = 2

pere_totali = bambini * pere_per_bambino
pere_mangiate = bambini_che_hanno_mangiato_le_pere * pere_mangiate_per_bambino
pere_arrivate_alla_festa = pere_totali - pere_mangiate

<span class="org-builtin">puts</span> <span class="org-string">"Alla festa sono arrivate:"</span> + pere_arrivate_alla_festa + <span class="org-string">"pere"</span>
</pre>
</div>

<p>
Lo salviamo come <i>pere2.rb</i> e come prima scriviamo nel <i>terminale</i>:
</p>

<div class="org-src-container">

<pre class="src src-sh">ruby pere2.rb
</pre>
</div>

<p>
Però c'è un problema:
</p>

<div class="org-src-container">

<pre class="src src-sh">&#10140;  source  ruby pere2.rb
pere2.rb:11:in <span class="org-sh-quoted-exec">`+': no implicit conversion of Fixnum into String (TypeError)</span>
<span class="org-sh-quoted-exec">        from pere2.rb:11:in `</span>&lt;main&gt;<span class="org-string">'</span>
<span class="org-string">&#10140;  source</span>
</pre>
</div>

<p>
Ruby non è riuscito a utilizzare la variabile <i>pere_arrivate_alla_festa</i> come se fosse una stringa e quindi ci avverte.
Per non incorrere in questo errore dobbiamo <i>convertire</i> il numero contenuto nella <i>variabile</i> in una stringa:
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-builtin">puts</span> <span class="org-string">"Alla festa sono arrivate:"</span> + pere_arrivate_alla_festa.to_s + <span class="org-string">"pere"</span>
</pre>
</div>

<p>
A <i>pere_arrivate_alla_festa</i> aggiungiamo <i>.to_s</i> e magicamente diventa una stringa.
</p>

<p>
Combiamo il programma così e salviamo come <i>pere3.rb</i>
</p>

<div class="org-src-container">

<pre class="src src-ruby">bambini = 10
pere_per_bambino = 3
bambini_che_hanno_mangiato_le_pere = 3
pere_mangiate_per_bambino = 2

pere_totali = bambini * pere_per_bambino
pere_mangiate = bambini_che_hanno_mangiato_le_pere * pere_mangiate_per_bambino
pere_arrivate_alla_festa = pere_totali - pere_mangiate

<span class="org-builtin">puts</span> <span class="org-string">"Alla festa sono arrivate: "</span> + pere_arrivate_alla_festa.to_s + <span class="org-string">" pere"</span>
</pre>
</div>

<p>
Eseguite il programma come prima:
</p>

<div class="org-src-container">

<pre class="src src-sh">&#10140;  source  ruby pere3.rb
Alla festa sono arrivate: 24 pere
&#10140;  source
</pre>
</div>

<p>
Meglio no?
</p>
</div>
</div>

<div id="outline-container-sec-3-4-4" class="outline-4">
<h4 id="sec-3-4-4"><span class="section-number-4">3.4.4</span> Riflessioni fino qui</h4>
<div class="outline-text-4" id="text-3-4-4">
<p>
In questa ultima parte abbiamo visto delle cose strane, delle <i>istruzioni</i> che sicuramente non abbiamo capito.
Per primo vediamo l'istruzione <i>puts</i>. È un <i>metodo</i>.
Nei linguaggi di programmazione si sente spesso parlare di <i>funzioni</i>, <i>procedure</i> o <i>metodi</i>; sono tutti un modo per indicare dei piccoli pezzi <i>codice</i> (il linguaggio di programmazione scritto) che possono essere riutilizzati tramite un nome che gli abbiamo dato. In Ruby, come in altri linguaggi simili, le <i>funzioni</i> vengono chiamate <i>metodi</i>.
Il <i>metodo</i> <i>puts</i> serve per scrivere del testo in uscita.
Spieghiamo questa cosa complicata con un esempio.
</p>

<p>
Immaginate una stanza con due porte, da una si entra e da una si esce. Quella da cui si entra, si chiama: <i>input</i>; quella da cui si esce: <i>output</i>.
Mettiamo che una sera la mamma debba uscire col babbo per una cena.
La mamma si vuole truccare per farsi bella e quindi:
</p>

<ul class="org-ul">
<li>entra dalla porta <i>input</i>
</li>
<li>dentro la stanza viene truccata da una estetista e diventa più bella
</li>
<li>esce dalla porta <i>output</i>
</li>
</ul>

<p>
Insomma, la mamma sono i dati del metodo (la stanza dell'estetista) che entra struccata ed esce truccata. <br >
</p>

<p>
<b>I dati (numeri o stringhe) entrano come <i>parametri</i> nel metodo e ne escono modificati o no.</b>
</p>

<p>
Il metodo <i>puts</i> è un metodo che Ruby fornisce da solo, come molti altri, ma noi li possiamo anche scrivere e cioè <i>definire</i> quando vogliamo. La definizione di <i>puts</i> ed il suo uso, per esempio, potrebbe essere come questa:
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-keyword">def</span> <span class="org-function-name">puts</span>(testo_in_output)
  testo_in_output
<span class="org-keyword">end</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">si pu&#242; invocare come:</span>
<span class="org-builtin">puts</span> <span class="org-string">"ciao mondo"</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">oppure:</span>

<span class="org-builtin">puts</span>(<span class="org-string">"ciao mondo"</span>)
</pre>
</div>

<p>
Come vedete possiamo <i>invocare</i> (cioè chiamare o usare) il metodo in due modi. Ruby permettere di non scrivere (<i>omettere</i>) le parentesi in alcuni casi.
Le righe che cominciano con <i>#</i> sono considerate dei <i>commenti</i>, del testo che possiamo scrivere dentro il <i>codice</i> senza che esso venga letto dall'interprete. Il <i>commento</i> va dal carattere <i>#</i> fino alla fine della riga. Se andate a capo senza mettere come primo carattere <i>#</i> Ruby vi darà un errore.
Si possono fare anche commenti su più righe. 
</p>

<p>
Per ricapitolare:
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-comment-delimiter">#</span><span class="org-comment">questo &#232; un commento che arriva fino in fondo alla riga</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">questo commento &#232;</span>
sbagliato

<span class="org-comment">=begin</span>
<span class="org-comment">questo</span>
<span class="org-comment">commento</span>
<span class="org-comment">va</span>
<span class="org-comment">bene</span>
<span class="org-comment">=end</span>
</pre>
</div>

<p>
La possibilità di commentare un codice è molto importante, perché così possiamo scrivere del testo per ricordarci cosa stiamo facendo o per descriverlo ad altri che lo leggeranno in seguito. <br >
</p>

<p>
Vediamo ora l'altro <i>metodo</i> che abbiamo usato: <i>to_s</i> <br >
Lo abbiamo usato in questo modo:
</p>

<div class="org-src-container">

<pre class="src src-ruby">pere_arrivate_alla_festa.to_s
</pre>
</div>

<p>
per convertire un numero intero in una stringa. Il metodo <i>to_s</i> significa semplicemente: <i>to string</i> (in stringa).
Ricordate che la lingua inglese è la lingua ufficiale per i linguaggi di programmazione, quindi le <i>cose</i> si chiameranno sempre in inglese. <br >
Il metodo <i>to_s</i> non ha dati in entrata (<i>input</i>), ma ugualmente fa qualcosa. Come vedete viene applicato invece a certi dati tramite il punto: <i>10.to_s fa diventare il 10 una stringa, "10"/.
Dovete sapere che Ruby è un linguaggio /orientato agli oggetti (Object Oriented)</i> e cioè un linguaggio in cui noi possiamo descrivere o definire degli oggetti che comunicano con altri oggetti. <br >
</p>

<p>
Complicato? <br >
</p>

<p>
Vediamo un po'. <br >
</p>

<p>
Molti di voi giocheranno coi mattoncini Lego<sup>(tm)</sup> o almeno saprete sicuramente cosa sono.
Sapete che ci sono molti mattoncini di forme diverse che si attaccano insieme. Bene!
I mattoncini Lego<sup>(tm)</sup> sono come un linguaggio <i>Object Oriented</i>. I mattoncini sono <i>oggetti</i>.
Se guardate un mattoncino, noterete che è diverso sopra e sotto, per permettervi di attaccarli insieme. La parte dove si attaccano è una <i>interfaccia</i> di collegamento. I rilievi rotondi su una delle superfici sono i <i>metodi</i>.
In Ruby si dice che tutto è un <i>oggetto</i> (è un linguaggio ad oggetti <i>puro</i>), quindi anche le stringhe ed i numeri.
</p>

<ul class="org-ul">
<li>L'oggetto delle stringhe si chiama: <i>String</i>.
</li>
<li>L'oggetto dei numeri si chiama: <i>Fixnum</i>.
</li>
</ul>

<p>
Il metodo <i>to_s</i> è quindi un metodo dell'oggetto <i>Fixnum</i>. È un metodo però che tutti gli oggetti in Ruby ha, come molti altri; ma li vedremo in seguito.
</p>

<p>
Il modo di <i>invocare</i> (chiamare o <i>call</i>) è quello tramite la <i>dot notation</i>, la <i>notazione a punto</i>.
Insomma per farla semplice: mettete un punto tra l'oggetto e il metodo. <br >
Ricordate come lanciare <i>irb</i>?
</p>

<div class="org-src-container">

<pre class="src src-ruby">irb(main)<span class="org-constant">:001</span>:0&gt; 10.to_s
=&gt; <span class="org-string">"10"</span>
irb(main)<span class="org-constant">:002</span>:0&gt; io_sono_un_numero = 12
=&gt; 12
irb(main)<span class="org-constant">:003</span>:0&gt; io_sono_un_numero.to_s
=&gt; <span class="org-string">"12"</span>
irb(main)<span class="org-constant">:004</span>:0&gt;
</pre>
</div>

<p>
Questi per esempio sono i metodi di <i>Fixnum</i>:
</p>

<div class="org-src-container">

<pre class="src src-ruby">irb(main)<span class="org-constant">:004</span>:0&gt; <span class="org-type">Fixnum</span>.methods
=&gt; [<span class="org-constant">:allocate</span>, <span class="org-constant">:superclass</span>, <span class="org-constant">:freeze</span>, <span class="org-constant">:===</span>, <span class="org-constant">:==</span>, <span class="org-constant">:&lt;=&gt;</span>, <span class="org-constant">:&lt;</span>, <span class="org-constant">:&lt;=</span>, <span class="org-constant">:&gt;</span>, <span class="org-constant">:&gt;=</span>, <span class="org-constant">:to_s</span>, <span class="org-constant">:inspect</span>, <span class="org-constant">:included_modules</span>, <span class="org-constant">:include?</span>, <span class="org-constant">:name</span>, <span class="org-constant">:ancestors</span>, <span class="org-constant">:instance_methods</span>, <span class="org-constant">:public_instance_methods</span>, <span class="org-constant">:protected_instance_methods</span>, <span class="org-constant">:private_instance_methods</span>, <span class="org-constant">:constants</span>, <span class="org-constant">:const_get</span>, <span class="org-constant">:const_set</span>, <span class="org-constant">:const_defined?</span>, <span class="org-constant">:const_missing</span>, <span class="org-constant">:class_variables</span>, <span class="org-constant">:remove_class_variable</span>, <span class="org-constant">:class_variable_get</span>, <span class="org-constant">:class_variable_set</span>, <span class="org-constant">:class_variable_defined?</span>, <span class="org-constant">:public_constant</span>, <span class="org-constant">:private_constant</span>, <span class="org-constant">:singleton_class?</span>, <span class="org-constant">:include</span>, <span class="org-constant">:prepend</span>, <span class="org-constant">:module_exec</span>, <span class="org-constant">:class_exec</span>, <span class="org-constant">:module_eval</span>, <span class="org-constant">:class_eval</span>, <span class="org-constant">:method_defined?</span>, <span class="org-constant">:public_method_defined?</span>, <span class="org-constant">:private_method_defined?</span>, <span class="org-constant">:protected_method_defined?</span>, <span class="org-constant">:public_class_method</span>, <span class="org-constant">:private_class_method</span>, <span class="org-constant">:autoload</span>, <span class="org-constant">:autoload?</span>, <span class="org-constant">:instance_method</span>, <span class="org-constant">:public_instance_method</span>, <span class="org-constant">:nil?</span>, <span class="org-constant">:=~</span>, <span class="org-constant">:!~</span>, <span class="org-constant">:eql?</span>, <span class="org-constant">:hash</span>, <span class="org-constant">:class</span>, <span class="org-constant">:singleton_class</span>, <span class="org-constant">:clone</span>, <span class="org-constant">:dup</span>, <span class="org-constant">:taint</span>, <span class="org-constant">:tainted?</span>, <span class="org-constant">:untaint</span>, <span class="org-constant">:untrust</span>, <span class="org-constant">:untrusted?</span>, <span class="org-constant">:trust</span>, <span class="org-constant">:frozen?</span>, <span class="org-constant">:methods</span>, <span class="org-constant">:singleton_methods</span>, <span class="org-constant">:protected_methods</span>, <span class="org-constant">:private_methods</span>, <span class="org-constant">:public_methods</span>, <span class="org-constant">:instance_variables</span>, <span class="org-constant">:instance_variable_get</span>, <span class="org-constant">:instance_variable_set</span>, <span class="org-constant">:instance_variable_defined?</span>, <span class="org-constant">:remove_instance_variable</span>, <span class="org-constant">:instance_of?</span>, <span class="org-constant">:kind_of?</span>, <span class="org-constant">:is_a?</span>, <span class="org-constant">:tap</span>, <span class="org-constant">:send</span>, <span class="org-constant">:public_send</span>, <span class="org-constant">:respond_to?</span>, <span class="org-constant">:extend</span>, <span class="org-constant">:display</span>, <span class="org-constant">:method</span>, <span class="org-constant">:public_method</span>, <span class="org-constant">:singleton_method</span>, <span class="org-constant">:define_singleton_method</span>, <span class="org-constant">:object_id</span>, <span class="org-constant">:to_enum</span>, <span class="org-constant">:enum_for</span>, <span class="org-constant">:equal?</span>, <span class="org-constant">:!</span>, <span class="org-constant">:!=</span>, <span class="org-constant">:instance_eval</span>, <span class="org-constant">:instance_exec</span>, <span class="org-constant">:__send__</span>, <span class="org-constant">:__id__</span>]
irb(main)<span class="org-constant">:005</span>:0&gt;
</pre>
</div>

<p>
Come vedete sono parecchi ed alcuni anche molto strani&#x2026; Cercate <i>to_s</i>.
</p>

<p>
Quello che ho chiamato per sapere questa lista è <i>methods</i>. Il metodo <i>methods</i> fa questo: restituisce una lista dei nomi dei metodi dell'oggetto su cui è invocato.
</p>

<p>
Nel gergo dei linguaggi orientati agli oggetti (puri) si dice: <i>mandare un messaggio ad un oggetto</i>.
Quindi in pratica ho <i>chiesto a Fixnum di dirmi tutti i nomi dei suoi metodi</i>. Come quando chiedete ad un amico di darvi il suo quaderno di matematica e lui ve lo da.
</p>
</div>
</div>

<div id="outline-container-sec-3-4-5" class="outline-4">
<h4 id="sec-3-4-5"><span class="section-number-4">3.4.5</span> Confrontare le cose e decidere cosa fare</h4>
<div class="outline-text-4" id="text-3-4-5">
<p>
Cominciamo a vedere le cose serie. Un programma non è un programma se non prendiamo decisioni.
Fino ad adesso abbiamo solo dato comandi ed è il momento di decidersi a <i>decidere</i>.
</p>

<p>
Per prima cosa guardiamo gli operatori <i>booleani</i> (si chiamano booleani da George Bool un matematico inglese dell'800):
</p>

<ul class="org-ul">
<li><b>&gt;</b> maggiore di&#x2026;
</li>
<li><b>&lt;</b> minore di&#x2026;
</li>
<li><b>&gt;=</b> maggiore od uguale di&#x2026;
</li>
<li><b>&lt;=</b> minore od uguale di&#x2026;
</li>
<li><b>==</b> uguale a&#x2026;
</li>
<li><b>!=</b> non uguale a&#x2026;
</li>
</ul>

<div class="org-src-container">

<pre class="src src-ruby">irb(main)<span class="org-constant">:001</span>:0&gt; 5 &gt; 2
=&gt; <span class="org-variable-name">true</span>
irb(main)<span class="org-constant">:002</span>:0&gt; 5 &lt; 2
=&gt; <span class="org-variable-name">false</span>
irb(main)<span class="org-constant">:003</span>:0&gt; 5 &gt;= 5
=&gt; <span class="org-variable-name">true</span>
irb(main)<span class="org-constant">:004</span>:0&gt; 5 &lt;=5
=&gt; <span class="org-variable-name">true</span>
irb(main)<span class="org-constant">:005</span>:0&gt; 5 == 5
=&gt; <span class="org-variable-name">true</span>
irb(main)<span class="org-constant">:006</span>:0&gt; 5 != 5
=&gt; <span class="org-variable-name">false</span>
irb(main)<span class="org-constant">:007</span>:0&gt;
</pre>
</div>

<p>
Con questi <i>operatori</i> possiamo sapere quindi se un numero è maggiore, minore od uguale ad un altro.
</p>

<p>
Lo possiamo fare anche con le stringhe:
</p>

<div class="org-src-container">

<pre class="src src-ruby">irb(main)<span class="org-constant">:001</span>:0&gt; 5 &gt; 2
=&gt; <span class="org-variable-name">true</span>
irb(main)<span class="org-constant">:002</span>:0&gt; 5 &lt; 2
=&gt; <span class="org-variable-name">false</span>
irb(main)<span class="org-constant">:003</span>:0&gt; 5 &gt;= 5
=&gt; <span class="org-variable-name">true</span>
irb(main)<span class="org-constant">:004</span>:0&gt; 5 &lt;=5
=&gt; <span class="org-variable-name">true</span>
irb(main)<span class="org-constant">:005</span>:0&gt; 5 == 5
=&gt; <span class="org-variable-name">true</span>
irb(main)<span class="org-constant">:006</span>:0&gt; 5 != 5
=&gt; <span class="org-variable-name">false</span>
irb(main)<span class="org-constant">:007</span>:0&gt;
</pre>
</div>

<p>
Questo non vi fa domandare cosa succede con le stringe? È interessante perché il confronto è fatto sul <i>valore lessicale</i> delle stringhe.
</p>

<p>
Guardate:
</p>

<div class="org-src-container">

<pre class="src src-ruby">irb(main)<span class="org-constant">:013</span>:0&gt; <span class="org-string">'a'</span> &gt; <span class="org-string">'b'</span>
=&gt; <span class="org-variable-name">false</span>
irb(main)<span class="org-constant">:014</span>:0&gt; <span class="org-string">'b'</span> &gt; <span class="org-string">'a'</span>
=&gt; <span class="org-variable-name">true</span>
irb(main)<span class="org-constant">:015</span>:0&gt;
</pre>
</div>

<p>
Capito? L'<i>ordine lessicale</i> è praticamente quello come nel dizionario con però un problema:
</p>

<div class="org-src-container">

<pre class="src src-ruby">irb(main)<span class="org-constant">:014</span>:0&gt; <span class="org-string">'b'</span> &gt; <span class="org-string">'a'</span>
=&gt; <span class="org-variable-name">true</span>
irb(main)<span class="org-constant">:015</span>:0&gt; <span class="org-string">'B'</span> &gt; <span class="org-string">'a'</span>
=&gt; <span class="org-variable-name">false</span>
irb(main)<span class="org-constant">:016</span>:0&gt;
</pre>
</div>

<p>
Come sarebbe? <i>b</i> è maggiore di <i>a</i> ma <i>B</i> no?
</p>

<p>
I computer ordinano in maniera diversa da noi, sono ancora più stupidi di quello che avevamo fino ad ora pensato, loro ordinano prima le lettere maiuscole e poi le minuscole (per la verità prima ordinano i numeri, poi le maiuscole e dopo le minuscole). Questo è un problema.
</p>

<p>
Dobbiamo quindi stare attenti, ma fortunatamente Ruby ci aiuta con il metodo <i>downcase</i> che mette la stringa tutta in minuscolo o <i>upcase</i> che la rende tutta maiuscola.
</p>

<div class="org-src-container">

<pre class="src src-ruby">irb(main)<span class="org-constant">:018</span>:0&gt; <span class="org-string">'B'</span>.downcase
=&gt; <span class="org-string">"b"</span>
irb(main)<span class="org-constant">:019</span>:0&gt; <span class="org-string">'B'</span>.downcase &gt; <span class="org-string">'a'</span>.downcase
=&gt; <span class="org-variable-name">true</span>
irb(main)<span class="org-constant">:020</span>:0&gt; <span class="org-string">'B'</span> &gt; <span class="org-string">'a'</span>
=&gt; <span class="org-variable-name">false</span>
irb(main)<span class="org-constant">:021</span>:0&gt; <span class="org-string">'a'</span>.upcase
=&gt; <span class="org-string">"A"</span>
irb(main)<span class="org-constant">:022</span>:0&gt;
</pre>
</div>

<p>
Ora abbiamo capito gli <i>operatori booleani</i> e che ci facciamo? Li usiamo per <i>decidere cosa fare</i>.
</p>

<p>
Prendete l'editor che scriviamo un programma nuovo.
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-builtin">puts</span> <span class="org-string">"Quanti anni hai?"</span>

eta = gets

<span class="org-keyword">if</span> eta == 9
  <span class="org-builtin">puts</span> <span class="org-string">"fai la quarta elementare"</span>
<span class="org-keyword">else</span>
  <span class="org-builtin">puts</span> <span class="org-string">"non fai la quarta elementare"</span>
<span class="org-keyword">end</span>
</pre>
</div>

<p>
Salvate come avete imparato con il nome <i>test.rb</i> e poi eseguitelo:
</p>

<div class="org-src-container">

<pre class="src src-sh">&#10140;  source  ruby test.rb 
Quanti anni hai?
8
non fai la quarta elementare
</pre>
</div>

<p>
Ora però proviamo scrivendo nove quando lo chiede:
</p>

<div class="org-src-container">

<pre class="src src-sh">&#10140;  source  ruby test.rb 
Quanti anni hai?
9
non fai la quarta elementare
</pre>
</div>

<p>
Qualcosa non va.
</p>

<p>
Intanto capiamo cosa è <i>gets</i>. Ricordate <i>puts</i> e gli <i>input</i> e <i>output</i>&#x2026; La mamma che va a cena?
Bene. Il metodo <i>gets</i> carica i dati dall'<i>input', cioè ci chiede di scrivere qualcosa e premere il tasto invio. I dati che prende li può caricare dentro una variabile.
Noi abbiamo messo l'età dentro la variabile /eta</i> (non ha l'accento perché come vi ho già detto i linguaggi di programmazione sono in <i>inglese</i> e l'inglese non ha accenti di questo tipo, quindi non tutti i caratteri possiamo usare per i nomi delle <i>variabili</i> o dei <i>metodi</i>. Non si possono usare nemmeno i caratteri degli operatori e se ci fate caso neanche gli spazi&#x2026; ), poi con un test abbiamo controllato il valore:
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-keyword">if</span> eta == 9
  <span class="org-builtin">puts</span> <span class="org-string">"fai la quarta elementare"</span>
<span class="org-keyword">else</span>
  <span class="org-builtin">puts</span> <span class="org-string">"non fai la quarta elementare"</span>
<span class="org-keyword">end</span>
</pre>
</div>

<p>
cioè: se (<i>if</i>) eta è uguale a 9 scrivi <i>fai la quarta elementare</i> altrimenti (<i>else</i>) scrivi <i>non fai la quarta elementare</i>. Noi però abbiamo scritto 9, perché non ha funzionato?
Ora ve lo spiego: il metodo <i>gets</i> legge i caratteri che scriviamo ma non sa che quelli sono numeri; per lui sono stringhe.
</p>

<p>
Ruby è un <i>linguaggio dinamico</i> e permette di valutare e confrontare le <i>pere con le mele</i>. La maestra vi avrà sicuramente detto che non si confrontano <i>le mele con le pere</i>&#x2026; La maestra ha ragione, ma i linguaggi di programmazione spesso non vanno proprio a braccetto con la matematica.
</p>


<p>
Scrivere così è perfettamente lecito:
</p>

<div class="org-src-container">

<pre class="src src-ruby">irb(main)<span class="org-constant">:023</span>:0&gt; <span class="org-string">"pere"</span> == 10
=&gt; <span class="org-variable-name">false</span>
irb(main)<span class="org-constant">:024</span>:0&gt;
</pre>
</div>

<p>
e giustamente restituisce il valore <i>falso</i> (<i>false</i>). Come mai? <br >
</p>

<p>
<b>Perché una stringa non è un numero</b>. <br >
</p>

<p>
Ruby, se i tipi del confronto non sono uguali o riconducibili, non confronta i valori ma i tipi stessi.
Sono sicuro che vi cominci ad arrivare un po' di mal di testa, quindi vediamo.
</p>

<p>
La stringa <i>pere</i> è di tipo String, il numero 10 è di tipo Fixnum (tutto questo lo abbiamo visto prima), Ruby lo sa che i tipi sono diversi e non può confrontare i valori, quindi ci dice che un tipo <i>String</i> non è un tipo <i>Fixnum</i>.
</p>

<p>
Lo so che la storia dei tipi è un po' complicata, ma piano piano la capirete e vedrete che è <i>ganzissima</i>.
</p>

<p>
Ritornando al problema di prima, quello del 9. Per far funzionare il programma noi dobbiamo convertire <i>eta</i> in un numero con il metodo <i>to_i</i> (<i>to integer</i>):
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-builtin">puts</span> <span class="org-string">"Quanti anni hai?"</span>

eta = gets.to_i

<span class="org-keyword">if</span> eta == 9
  <span class="org-builtin">puts</span> <span class="org-string">"fai la quarta elementare"</span>
<span class="org-keyword">else</span>
  <span class="org-builtin">puts</span> <span class="org-string">"non fai la quarta elementare"</span>
<span class="org-keyword">end</span>
</pre>
</div>

<p>
Però sarebbe meglio anche aggiungere un altro metodo: <i>chomp</i>; che rimuove il carattere di invio. Quando scrivete 9 e date invio, anche il carattere di invio viene mandato al programma. Ecco, <i>chomp</i> rimuove il carattere di invio dalla stringa (il carattere invisibile <i>newline</i> ovvero <i>nuova riga</i>).
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-builtin">puts</span> <span class="org-string">"Quanti anni hai?"</span>

eta = gets.chomp.to_i

<span class="org-keyword">if</span> eta == 9
  <span class="org-builtin">puts</span> <span class="org-string">"fai la quarta elementare"</span>
<span class="org-keyword">else</span>
  <span class="org-builtin">puts</span> <span class="org-string">"non fai la quarta elementare"</span>
<span class="org-keyword">end</span>
</pre>
</div>

<p>
Qui vedete anche un'altra cosa interessante, i metodi possono essere <i>chained</i> (<i>concatenati</i>); messi uno dopo l'altro e concatenati con il punto. Ogni metodo passerà a quello dopo il valore che ha elaborato: <br >
</p>

<p>
<b><i>gets</i> legge '9' + <i>newline</i>, lo passa a <i>chomp</i> che leva il <i>newline</i> e passa '9' a <i>to_i</i> che lo trasforma in un intero dal valore 9</b> <br >
</p>

<p>
La condizione <i>if</i> valuta sempre una espressione che restituisce un valore <i>booleano</i>: <i>true</i> o <i>false</i>, vero o falso; quindi possiamo utilizzare una <i>qualunque</i> espressione che restituisce vero a falso. Ricordatelo, servirà.
La condizione <i>if</i> può essere semplice:
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-keyword">if</span> a &gt; 1
  <span class="org-builtin">puts</span> <span class="org-string">'a &#232; maggiore di uno'</span>
<span class="org-keyword">end</span>
</pre>
</div>

<p>
o come abbiamo visto prima una alternativa contrassegnata dalla <i>parola chiave</i> (<i>keyword</i>) <i>else</i> (<i>altrimenti</i>).
La cosa interessante è che dentro un blocco <i>if..end</i> o <i>if..else..end</i> possiamo mettere dentro, <i>annidare</i>, altre condizioni:
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-keyword">if</span> a &gt; 1
  <span class="org-builtin">puts</span> <span class="org-string">'a &#232; maggiore di 1'</span>
<span class="org-keyword">else</span>
  <span class="org-keyword">if</span> a == 0
    <span class="org-builtin">puts</span> <span class="org-string">'a &#232; uguale zero'</span>
  <span class="org-keyword">else</span>
    <span class="org-builtin">puts</span> <span class="org-string">'a &#232; minore di zero'</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>
</div>

<p>
Si potrebbe anche scrivere meglio, ma va bene per capire. Come vedete il test prima controlla se <i>a è maggiore di 1</i>, se non lo è ci chiediamo: <i>a è uguale a zero?</i> se lo è lo scriviamo, altrimenti sarà per forza <i>minore di zero</i>. In questa maniera, <i>annidando</i> delle condizioni abbiamo valutato i tre possibili stati di un numero:
</p>

<ul class="org-ul">
<li>è maggiore di zero
</li>
<li>è zero
</li>
<li>è minore di zero
</li>
</ul>

<p>
Se modifichiamo il programma di prima e lo salviamo come <i>test2.rb</i>:
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-builtin">puts</span> <span class="org-string">"Quanti anni hai?"</span>

eta = gets.to_i

<span class="org-keyword">if</span> eta == 9
  <span class="org-builtin">puts</span> <span class="org-string">"fai la quarta elementare"</span>
<span class="org-keyword">else</span>
  <span class="org-keyword">if</span> eta &lt; 9
    <span class="org-builtin">puts</span> <span class="org-string">"sei ancora piccolo e fai la prima o la seconda o la terza"</span>
  <span class="org-keyword">else</span>
    <span class="org-builtin">puts</span> <span class="org-string">"Sei gi&#224; laureato?"</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>
</div>

<p>
Pensate a quanti <i>giochini</i> potremmo fare con la possibilità di <i>annidare</i> le condizioni. 
Questo in gergo si chiama: <i>ramo decisionale</i>.
Visto che parliamo di <i>ramo decisionale</i> prima di guardare i <i>cicli</i> (<i>loop</i>) vediamo un altro modo per prendere le decisioni.
È un modo molto potente ed utile, che ci permette di scrivere meglio il programma di prima.
</p>

<p>
Salvatelo come <i>test3.rb</i> ed eseguite come avete imparato:
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-builtin">puts</span> <span class="org-string">"Quanti anni hai?"</span>

eta = gets.to_i

<span class="org-keyword">case</span> eta
<span class="org-keyword">when</span> 6
  <span class="org-builtin">puts</span> <span class="org-string">'fai la prima elementare'</span>
<span class="org-keyword">when</span> 7
  <span class="org-builtin">puts</span> <span class="org-string">'fai la seconda elementare'</span>
<span class="org-keyword">when</span> 8
  <span class="org-builtin">puts</span> <span class="org-string">'fai la terza elementare'</span>
<span class="org-keyword">when</span> 9
  <span class="org-builtin">puts</span> <span class="org-string">'fai la quarta elementare'</span>
<span class="org-keyword">when</span> 10
  <span class="org-builtin">puts</span> <span class="org-string">'fai la quinta elementare'</span>
<span class="org-keyword">else</span>
  <span class="org-keyword">if</span> eta &gt; 10
  <span class="org-builtin">puts</span> <span class="org-string">'Vai alle medie?'</span>
  <span class="org-keyword">else</span>
    <span class="org-builtin">puts</span> <span class="org-string">"Fai ancora l'asilo"</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>
</div>

<p>
Ho usato l'<i>espressione condizionale</i> <i>case..when..end</i>. È nella sua <i>forma completa</i>: if..when..else..end.
Vediamo che succede in questo caso.
Questa espressione è come una cassettiera con i cassetti numerati, ci sono cinque cassetti numerati 6,7,8,9,10 e un ultimo dove si mette tutto quello che non va negli altri.
Qui ho usato anche una condizione <i>if..else..end</i> per diramare ulteriormente il test. 
</p>

<p>
Eseguendolo potete vedere i risultati:
</p>

<div class="org-src-container">

<pre class="src src-sh">&#10140;  source  ruby test3.rb 
Quanti anni hai?
2
Fai ancora l<span class="org-string">'asilo</span>
<span class="org-string">&#10140;  source  ruby test3.rb</span>
<span class="org-string">Quanti anni hai?</span>
<span class="org-string">6</span>
<span class="org-string">fai la prima elementare</span>
<span class="org-string">&#10140;  source  ruby test3.rb</span>
<span class="org-string">Quanti anni hai?</span>
<span class="org-string">11</span>
<span class="org-string">Vai alle medie?</span>
<span class="org-string">&#10140;  source  ruby test3.rb</span>
<span class="org-string">Quanti anni hai?</span>
<span class="org-string">10</span>
<span class="org-string">fai la quinta elementare</span>
<span class="org-string">&#10140;  source</span>
</pre>
</div>

<p>
L'espressione <i>case..when..end</i> è davvero molto utile, cose come queste ci sono i tutti i linguaggi di programmazione anche se a volte meno potenti. In Ruby potete valutare praticamente qualunque cosa.
</p>

<p>
Ecco una stringa:
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-keyword">case</span> nome
  <span class="org-keyword">when</span> <span class="org-string">'pippo'</span>
    <span class="org-builtin">puts</span> <span class="org-string">'ti chiami pippo'</span>
  <span class="org-keyword">else</span>
    <span class="org-builtin">puts</span> <span class="org-string">'non ti chiami pippo'</span>
<span class="org-keyword">end</span>
</pre>
</div>

<p>
Simuliamo una condizione <i>if..else..end</i>:
</p>

<div class="org-src-container">

<pre class="src src-ruby">test_booleano = <span class="org-variable-name">true</span>

<span class="org-keyword">case</span> test_booleano
  <span class="org-keyword">when</span> <span class="org-variable-name">true</span>
    <span class="org-builtin">puts</span> <span class="org-string">'vero'</span>
  <span class="org-keyword">when</span> <span class="org-variable-name">false</span>
    <span class="org-builtin">puts</span> <span class="org-string">'falso'</span>
<span class="org-keyword">end</span>
</pre>
</div>

<p>
L'espressione <i>case..when..end</i> è <b>utilissima</b> e spesso mantiene il <i>codice</i> pulito e facilmente leggibile, provate e divertitevi.
</p>

<p>
Nelle <i>espressioni condizionali</i> possiamo fare più test insieme. Come?
Con gli operatori logici: 
</p>

<ul class="org-ul">
<li><b>or</b>, che si può scrivere spesso anche come <b>||</b>
</li>
<li><b>and</b> che si può scrivere spesso anche come <b>&amp;&amp;</b>
</li>
<li><b>not</b> che si può scrivere spesso anche come <b>!</b>
</li>
</ul>

<p>
La differenza tra quello scritto e quello a simbolo (<i>and</i> e <i>&amp;&amp;</i>) sta nel livello di precedenza di valutazione: la versione scritta ha una precedenza più bassa. Normalmente non ve ne curate, ma può causare a volte problemi subdoli. Nel dubbio è preferibile la versione simbolica.
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-keyword">if</span> a &gt;= 0 &amp;&amp; a &lt;= 9
  <span class="org-builtin">puts</span> <span class="org-string">'la variabile a &#232; compresa tra 0 e 9'</span>
<span class="org-keyword">end</span>
</pre>
</div>

<p>
Qui abbiamo detto a Ruby: <i>se la variabile a è maggiore od uguale 0 <b>e</b> la variabile a è minore od uguale a 9, scrivi&#x2026;</i>
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-keyword">if</span> nome == <span class="org-string">'pippo'</span> || nome == <span class="org-string">'pluto'</span>
  <span class="org-builtin">puts</span> <span class="org-string">'ti chiami pippo o pluto'</span>
<span class="org-keyword">else</span>
  <span class="org-builtin">puts</span> <span class="org-string">'il tuo nome &#232; un altro'</span>
<span class="org-keyword">end</span>
</pre>
</div>

<p>
Qui invece: <i>se la variabile nome contiene la stringa pippo <b>o</b> la variabile nome contiene la stringa pluto, scrivi&#x2026;</i>
</p>

<p>
Si possono mettere più condizioni su uno stesso <i>if..else..end</i>, certo bisogna fare attenzione, molta attenzione. Se avete condizioni multiple, dato che hanno la stessa precedenza e vengono valutate da sinistra verso destra, a volte avrete bisogno delle parentesi per raggruppare le valutazioni.
L'operatore <i>not</i> è di tipo <i>unario</i> e quindi si applica solo ad un <i>operando</i>: <i>!true</i> è uguale a <i>false</i> come <i>non vero</i> è uguale a <i>falso</i>. Gli altri invece si dicono <i>binari</i> perché si applicano a due operandi.
Ne esiste anche uno <i>terziario</i> che serve per esprimere una condizione su una sola riga:
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-comment-delimiter">#</span><span class="org-comment">questa riga &#232; equivalente al test if..else..end</span>
condizione ? <span class="org-builtin">puts</span>(<span class="org-string">'vera'</span>) : <span class="org-builtin">puts</span>(<span class="org-string">'falsa'</span>)

<span class="org-keyword">if</span> condizione
  <span class="org-builtin">puts</span> <span class="org-string">'vera'</span>
<span class="org-keyword">else</span>
  <span class="org-builtin">puts</span> <span class="org-string">'falsa'</span>
<span class="org-keyword">end</span>
</pre>
</div>

<p>
I due test sono equivalenti.
</p>

<p>
Ruby ha anche un'altra sintassi per i test negativi: <i>unless..else..end</i>. In pratica: <i>se non è vero fai qualcosa altrimenti fai altro</i>.
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-keyword">if</span> a != 1
  <span class="org-builtin">puts</span> <span class="org-string">'a &#232; diverso da 1'</span>
<span class="org-keyword">end</span>

<span class="org-keyword">unless</span> a == 1
  <span class="org-builtin">puts</span> <span class="org-string">'a &#232; diverso da 1'</span>
<span class="org-keyword">end</span>
</pre>
</div>

<p>
I due test sono equivalenti. Il test <i>unless</i> vi assicuro che è davvero comodo, perché più spesso di quanto possiate credere è più chiaro e facilmente capibile il controllare che una cosa non sia vera.
</p>
</div>
</div>

<div id="outline-container-sec-3-4-6" class="outline-4">
<h4 id="sec-3-4-6"><span class="section-number-4">3.4.6</span> Cicli, ripetere le cose da fare molte volte</h4>
<div class="outline-text-4" id="text-3-4-6">
<p>
I <i>cicli</i> ci permettono di ripete delle <i>istruzioni</i> più volte. 
Ruby ha alcuni tipi di cicli come la maggior parte dei linguaggi di programmazione.
</p>

<ul class="org-ul">
<li><b>while..end</b>, <b>finché</b> la condizione è vera fai qualcosa
</li>
<li><b>until..end</b>, finché la condizione è falsa fai qualcosa
</li>
<li><b>for..in..end</b>, per ogni valore all'interno di un insieme di valori fai qualcosa
</li>
</ul>

<p>
È un po' come <i>if</i> e <i>unless</i>.
</p>

<p>
Ora vi dico una cosa, è abbastanza raro usare questi cicli in Ruby e lo vedrete più avanti.
</p>

<p>
Scrivete nel vostro editor il programma che segue, salvatelo come <i>loop.rb</i> ed eseguitelo:
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-builtin">puts</span> <span class="org-string">'Inserisci un numero'</span>
numero = gets.chomp.to_i

<span class="org-keyword">while</span> numero != 10
  <span class="org-builtin">puts</span> <span class="org-string">'il mumero &#232; diverso dal numero segreto'</span>
  <span class="org-builtin">puts</span> <span class="org-string">'Inserisci un numero'</span>
  numero = gets.chomp.to_i
<span class="org-keyword">end</span> 

<span class="org-builtin">puts</span> <span class="org-string">'hai trovato il numero segreto. Complimenti!'</span>
</pre>
</div>

<p>
Il ciclo eseguirà le istruzioni date dentro di lui finché il numero inserito non sarà 10.
</p>

<p>
Se adesso uso <i>until</i> invece di <i>while</i>:
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-builtin">puts</span> <span class="org-string">'Inserisci un numero'</span>
numero = gets.chomp.to_i

<span class="org-keyword">until</span> numero != 10
  <span class="org-builtin">puts</span> <span class="org-string">'il mumero &#232; diverso dal numero segreto'</span>
  <span class="org-builtin">puts</span> <span class="org-string">'Inserisci un numero'</span>
  numero = gets.chomp.to_i
<span class="org-keyword">end</span> 

<span class="org-builtin">puts</span> <span class="org-string">'hai trovato il numero segreto. Complimenti!'</span>
</pre>
</div>

<p>
Visto che viene valutata la <i>falsità</i> funzionerà al contrario.
</p>

<p>
Il ciclo <i>for</i> invece prenderà un valore da un insieme di valori assegnandolo ad una <i>variabile</i> fino ad esaurire tutti i valori.
Sembra complicato ma non lo è molto.
</p>

<div class="org-src-container">

<pre class="src src-ruby">numeri = [0,1,2,3,4,5,6,7,8,9]

<span class="org-keyword">for</span> numero <span class="org-keyword">in</span> numeri
  <span class="org-builtin">puts</span> numero
<span class="org-keyword">end</span>
</pre>
</div>

<p>
Se lo eseguite come sapete:
</p>

<div class="org-src-container">

<pre class="src src-sh">&#10140;  source  ruby loop2.rb
0
1
2
3
4
5
6
7
8
9
&#10140;  source
</pre>
</div>

<p>
Il programma ha stampato tutti i numeri compresi nell'<i>array</i> chiamato <i>numeri</i>.
Vediamo però subito cosa è un <i>array</i> (tipo <i>Array</i>). È una collezione di <i>elementi</i>, in questo caso numeri. Non l'ho chiamato <i>insieme</i> perché esiste nella <i>libreria</i> Ruby un tipo <i>Set</i> che serve apposta per gli <i>insiemi matematici</i>.
È più corretto chiamare questi tipi di dati <i>collezioni</i> e noi vogliamo imparare il modo più corretto possibile di nominare le cose.
</p>

<p>
Agli elementi contenuti in una <i>collezione</i> si può accedere direttamente se si vuole:
</p>

<div class="org-src-container">

<pre class="src src-ruby">array = [1,2,3,4,5,6]

primo_elemento = array[0]
secondo_elemento = array[1]
</pre>
</div>

<p>
Vi si accede tramite quello che si chiama <i>indice</i> dell'array. Gli array sono <b>indicizzati a partire da zero</b>, questo lo dovete ricordare bene.
Ci sono anche i metodi <i>first</i> e <i>last</i> che come dicono i loro nomi accedono al primo e l'ultimo elemento. A volte ci interessa anche sapere quanti elemeti ci sono nell'array e quindi abbiamo <i>size</i>.
</p>

<p>
Qualcuno furbo ha capito l'<i>inghippo</i> della indicizzazione da zero?
</p>

<div class="org-src-container">

<pre class="src src-ruby">irb(main)<span class="org-constant">:003</span>:0&gt; array = [0,1,2,3,4,5,6,7,8,9]
=&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
irb(main)<span class="org-constant">:004</span>:0&gt; array.first
=&gt; 0
irb(main)<span class="org-constant">:005</span>:0&gt; array.last
=&gt; 9
irb(main)<span class="org-constant">:006</span>:0&gt; array.size
=&gt; 10
irb(main)<span class="org-constant">:007</span>:0&gt; array[0]
=&gt; 0
irb(main)<span class="org-constant">:008</span>:0&gt; array[3]
=&gt; 3
irb(main)<span class="org-constant">:009</span>:0&gt; array[array.size]
=&gt; <span class="org-variable-name">nil</span>
irb(main)<span class="org-constant">:010</span>:0&gt; array[array.size - 1]
=&gt; 9
irb(main)<span class="org-constant">:011</span>:0&gt;
</pre>
</div>

<p>
Capito? 
</p>

<p>
Una nota: il valore <i>nil</i> è un valore particolare che ha un significato analogo al latino <i>nihil</i> cioè <i>il nulla</i>. È il valore che si ha quando si leggono cose che non esistono: variabili, valori&#x2026;
</p>

<p>
Insomma un <i>array</i> è come una scatola con gli scompartimenti ed ogni scompartimento può contenere qualsiasi tipo di dato supportato da Ruby: numeri, stringhe, array&#x2026;
Non solo, un <i>array</i> in Ruby contrariamente ad altri linguaggi può mischiare i tipi.
</p>

<div class="org-src-container">

<pre class="src src-ruby">array = [1, 2, <span class="org-string">"pippo"</span>, 3, <span class="org-string">"pluto"</span>, [<span class="org-string">'a'</span>,<span class="org-string">'b'</span>,<span class="org-string">'c'</span>]]
</pre>
</div>

<p>
Immaginate adesso le <i>odiose</i> tabelline, quelle che la maestra vi chiede continuamente&#x2026; Bene, la tabella pitagorica è un array (in questo caso a due dimensioni). <br >
</p>

<p>
Qualcuno furbo ha già capito come far fare una tabella pitagorica a Ruby?
</p>

<div class="org-src-container">

<pre class="src src-ruby">numeri = [1,2,3,4,5,6,7,8,9,10]

<span class="org-keyword">for</span> numero <span class="org-keyword">in</span> numeri
  riga = <span class="org-string">''</span>
  <span class="org-keyword">for</span> moltiplicatore <span class="org-keyword">in</span> numeri
    valore = numero * moltiplicatore
    <span class="org-keyword">if</span> valore &lt; 10
      separatore = <span class="org-string">'  '</span>
    <span class="org-keyword">else</span>
      separatore = <span class="org-string">' '</span>
    <span class="org-keyword">end</span>
    riga = riga + valore.to_s + separatore
  <span class="org-keyword">end</span>
  <span class="org-builtin">puts</span> riga
<span class="org-keyword">end</span>
</pre>
</div>

<p>
Eseguitelo&#x2026;
</p>

<div class="org-src-container">

<pre class="src src-sh">&#10140;  source  ruby tabellina.rb 
1  2  3  4  5  6  7  8  9  10 
2  4  6  8  10 12 14 16 18 20 
3  6  9  12 15 18 21 24 27 30 
4  8  12 16 20 24 28 32 36 40 
5  10 15 20 25 30 35 40 45 50 
6  12 18 24 30 36 42 48 54 60 
7  14 21 28 35 42 49 56 63 70 
8  16 24 32 40 48 56 64 72 80 
9  18 27 36 45 54 63 72 81 90 
10 20 30 40 50 60 70 80 90 100 
&#10140;  source
</pre>
</div>

<p>
Che ne dite? Va bene? (Si potrebbe anche fare meglio, ma per ora va bene così).
Guardate bene il codice e cercate di capire, avete tutte le informazioni per farlo.
</p>

<p>
Come vi ho già detto, i cicli in Ruby non sono molto usati perché ha anche altri modi di fare la stessa cosa in maniera più compatta e leggibile.
</p>

<div class="org-src-container">

<pre class="src src-ruby">numeri = [1,2,3,4,5,6,7,8,9,10]

tabella = numeri.map <span class="org-keyword">do</span> |numero|
  riga = numeri.map <span class="org-keyword">do</span> |moltiplicatore|
    valore = numero * moltiplicatore
    separatore = valore &lt; 10 ? <span class="org-string">'  '</span> : <span class="org-string">' '</span>
    valore.to_s + separatore
  <span class="org-keyword">end</span>
  riga.join
<span class="org-keyword">end</span>
<span class="org-builtin">puts</span> tabella.join(<span class="org-string">"\n"</span>)
</pre>
</div>

<p>
Questo ne è un esempio, anche se non pare adesso quando sarete più bravi vi sembrerà meglio di quello sopra:
</p>

<div class="org-src-container">

<pre class="src src-ruby">numeri = [1,2,3,4,5,6,7,8,9,10]

<span class="org-builtin">puts</span> (numeri.map { |numero|
        (numeri.map { |moltiplicatore|
          valore = numero * moltiplicatore
          separatore = valore &lt; 10 ? <span class="org-string">'  '</span> : <span class="org-string">' '</span>
          valore.to_s + separatore
        }).join
      }).join(<span class="org-string">"\n"</span>)
</pre>
</div>

<p>
Per arrivare magari a questo:
</p>

<div class="org-src-container">

<pre class="src src-ruby">numeri = [1,2,3,4,5,6,7,8,9,10]
<span class="org-builtin">puts</span> (numeri.map { |numero|
        (numeri.map { |moltiplicatore| 
          (valore = numero * moltiplicatore).to_s + (valore &lt; 10 ? <span class="org-string">'  '</span> : <span class="org-string">' '</span>) 
        }).join
      }).join(<span class="org-string">"\n"</span>)
</pre>
</div>

<p>
Forse troverete anche altri modi&#x2026;
Negli ultimi due esempi, ci sono delle cose da notare che fanno di Ruby un linguaggio particolare (detto <i>funzionale</i>). Il concetto non è semplice.
</p>

<p>
Cercate di stare attenti, questa cosa che dirò adesso non è facile.
Le istruzioni, le variabili ed i metodi che usiamo in Ruby vivono dentro un <i>contesto</i>. Cosa è?
Pensate a casa vostra, quello è il vostro contesto. Pensate alla scuola, l'aula. L'aula è il vostro <i>contesto</i> e cioè la zona <i>chiusa</i> dove state e dove fate qualcosa.
In Ruby si possono fare queste <i>stanze</i> in vari modi: con le parentesi per esempio ma anche con parole chiave (<i>keywords</i>) particolari come <i>do..end</i>.
</p>

<p>
Le <i>keywords</i> <i>do..end</i> corrispondono a <i>{..}</i> e definiscono quello che viene chiamato <i>blocco</i> ma anche <i>closure</i> (<i>chiusura</i>).
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-comment-delimiter">#</span><span class="org-comment">prima forma</span>
<span class="org-keyword">do</span> |parametro|
  ...
<span class="org-keyword">end</span>

seconda forma
{ |parametro|
  ...
}
</pre>
</div>

<p>
Queste forme sono <i>closure</i> con un valore in entrata.
</p>

<p>
Vediamo il metodo <i>each</i> che è un metodo del tipo Array (ma anche altri tipi lo hanno):
</p>

<div class="org-src-container">

<pre class="src src-ruby">[1,2,3,4,5,6,7,8,9,10].each {|numero|
  <span class="org-builtin">puts</span> numero
}

<span class="org-keyword">for</span> numero <span class="org-keyword">in</span> [1,2,3,4,5,6,7,8,9,10]
  <span class="org-builtin">puts</span> numero
<span class="org-keyword">end</span>
</pre>
</div>

<p>
Le due forme sono equivalenti, cioè portano allo stesso risultato e stamperanno in <i>output</i> i valori contenuti nell'array.
La differenza è di tipo <i>paradigmatico</i>.
Vedo già le vostre facce sconvolte. - E che vuol dire? -.
</p>

<p>
Un <i>paradigma</i> è un modo, un metodo per fare qualcosa. Delle regole. Un paradigma di calcolo è quello che usate per fare le divisioni o altri calcoli per esempio. Si potrebbero fare in molti modi e voi ne usate uno di questi. Nei linguaggi di programmazione ci sono molti modi di fare le cose, molti <i>paradigmi di programmazione</i>.
</p>

<p>
Se noi scriviamo con il <i>for..in..end</i> usiamo quello che viene detto <i>paradigma imperativo</i>, se usiamo il metodo <i>each</i> quello detto <i>paradigma funzionale</i>.
Ruby ci permette di farlo nei due modi e ci lascia liberi di usare quello che ci piace di più.
Vedrete poi che quello <i>funzionale</i> è generalmente migliore, ma lo capirete da soli.
</p>

<p>
Insomma, <i>each</i> è un metodo del tipo array che come parametro in <i>input</i> prende una <i>closure</i> o una <i>lambda</i> o un oggetto Proc passando nel parametro di questi il valore di ogni elemento dell'array su cui è chiamato. <br >
</p>

<p>
Bene, ora ci vuole un mese di vacanza per riposarci!
</p>

<p>
A parte le chiacchiere e le definizioni da secchioni, una volta usata è più semplice del previsto.
Se guardate il codice sopra, immaginate che dentro <i>numero</i> ci vada finire dentro di volta in volta 1 poi 2 poi 3 poi 4 e così via fino a 10 che è l'ultimo elemento della collezione. Nel codice dentro la <i>closure</i> potere usare poi <i>numero</i> e fare quello che volete. Qui lo stampiamo in <i>output</i>.
</p>

<p>
Negli esempi io ho usato il metodo <i>map</i>, che è simile ad <i>each</i>, ma mentre <i>each</i> invoca la <i>closure</i> per ogni elemento della collezione senza fare altro, <i>map</i> cosa fa&#x2026; restituisce un'altra collezione coi dentro i risultati della elaborazione della <i>closure</i>.
Nell'esempio poi trasformo una collezione in una stringa usando il metodo <i>join</i> (<i>unisci</i>), un metodo che prende tutti gli elementi della collezione e li concatena come una stringa.
</p>

<p>
Questo modo di <i>ciclare</i> (brutta parola e si dice solo qui&#x2026; è come le parolacce) si chiama più giustamente <i>iterazione</i> e questi metodi si chiamano <i>iteratori</i>.
Un altro metodo <i>iteratore</i> è per esempio <i>times</i> che però è dei numeri e non degli array:
</p>

<div class="org-src-container">

<pre class="src src-ruby">10.times <span class="org-keyword">do</span> 
  <span class="org-builtin">puts</span> <span class="org-string">"ciao!"</span>
<span class="org-keyword">end</span>
</pre>
</div>

<p>
Verrà scritto in <i>output</i> dieci volte ciao.
Usare gli <i>iteratori</i> è molto importante e rende il <i>codice</i> meglio organizzabile e leggibile.
</p>

<p>
Questa è la lista dei metodi disponibili per il tipo Array:
</p>

<div class="org-src-container">

<pre class="src src-ruby">irb(main)<span class="org-constant">:001</span>:0&gt; <span class="org-type">Array</span>.methods.sort
=&gt; [<span class="org-constant">:!</span>, <span class="org-constant">:!=</span>, <span class="org-constant">:!~</span>, <span class="org-constant">:&lt;</span>, <span class="org-constant">:&lt;=</span>, <span class="org-constant">:&lt;=&gt;</span>, <span class="org-constant">:==</span>, <span class="org-constant">:===</span>, <span class="org-constant">:=~</span>, <span class="org-constant">:&gt;</span>, <span class="org-constant">:&gt;=</span>, <span class="org-constant">:[]</span>, <span class="org-constant">:__id__</span>, <span class="org-constant">:__send__</span>, <span class="org-constant">:allocate</span>, <span class="org-constant">:ancestors</span>, <span class="org-constant">:autoload</span>, <span class="org-constant">:autoload?</span>, <span class="org-constant">:class</span>, <span class="org-constant">:class_eval</span>, <span class="org-constant">:class_exec</span>, <span class="org-constant">:class_variable_defined?</span>, <span class="org-constant">:class_variable_get</span>, <span class="org-constant">:class_variable_set</span>, <span class="org-constant">:class_variables</span>, <span class="org-constant">:clone</span>, <span class="org-constant">:const_defined?</span>, <span class="org-constant">:const_get</span>, <span class="org-constant">:const_missing</span>, <span class="org-constant">:const_set</span>, <span class="org-constant">:constants</span>, <span class="org-constant">:define_singleton_method</span>, <span class="org-constant">:display</span>, <span class="org-constant">:dup</span>, <span class="org-constant">:enum_for</span>, <span class="org-constant">:eql?</span>, <span class="org-constant">:equal?</span>, <span class="org-constant">:extend</span>, <span class="org-constant">:freeze</span>, <span class="org-constant">:frozen?</span>, <span class="org-constant">:hash</span>, <span class="org-constant">:include</span>, <span class="org-constant">:include?</span>, <span class="org-constant">:included_modules</span>, <span class="org-constant">:inspect</span>, <span class="org-constant">:instance_eval</span>, <span class="org-constant">:instance_exec</span>, <span class="org-constant">:instance_method</span>, <span class="org-constant">:instance_methods</span>, <span class="org-constant">:instance_of?</span>, <span class="org-constant">:instance_variable_defined?</span>, <span class="org-constant">:instance_variable_get</span>, <span class="org-constant">:instance_variable_set</span>, <span class="org-constant">:instance_variables</span>, <span class="org-constant">:is_a?</span>, <span class="org-constant">:kind_of?</span>, <span class="org-constant">:method</span>, <span class="org-constant">:method_defined?</span>, <span class="org-constant">:methods</span>, <span class="org-constant">:module_eval</span>, <span class="org-constant">:module_exec</span>, <span class="org-constant">:name</span>, <span class="org-constant">:new</span>, <span class="org-constant">:nil?</span>, <span class="org-constant">:object_id</span>, <span class="org-constant">:prepend</span>, <span class="org-constant">:private_class_method</span>, <span class="org-constant">:private_constant</span>, <span class="org-constant">:private_instance_methods</span>, <span class="org-constant">:private_method_defined?</span>, <span class="org-constant">:private_methods</span>, <span class="org-constant">:protected_instance_methods</span>, <span class="org-constant">:protected_method_defined?</span>, <span class="org-constant">:protected_methods</span>, <span class="org-constant">:public_class_method</span>, <span class="org-constant">:public_constant</span>, <span class="org-constant">:public_instance_method</span>, <span class="org-constant">:public_instance_methods</span>, <span class="org-constant">:public_method</span>, <span class="org-constant">:public_method_defined?</span>, <span class="org-constant">:public_methods</span>, <span class="org-constant">:public_send</span>, <span class="org-constant">:remove_class_variable</span>, <span class="org-constant">:remove_instance_variable</span>, <span class="org-constant">:respond_to?</span>, <span class="org-constant">:send</span>, <span class="org-constant">:singleton_class</span>, <span class="org-constant">:singleton_class?</span>, <span class="org-constant">:singleton_method</span>, <span class="org-constant">:singleton_methods</span>, <span class="org-constant">:superclass</span>, <span class="org-constant">:taint</span>, <span class="org-constant">:tainted?</span>, <span class="org-constant">:tap</span>, <span class="org-constant">:to_enum</span>, <span class="org-constant">:to_s</span>, <span class="org-constant">:trust</span>, <span class="org-constant">:try_convert</span>, <span class="org-constant">:untaint</span>, <span class="org-constant">:untrust</span>, <span class="org-constant">:untrusted?</span>]
irb(main)<span class="org-constant">:002</span>:0&gt;
</pre>
</div>

<p>
Ho fatto la stessa cosa fatta indietro con Fixnum, ricordate? Ho qui però usato un nuovo metodo: <i>sort</i>. Il metodo <i>sort</i> mette in ordine un array.
</p>
</div>
</div>

<div id="outline-container-sec-3-4-7" class="outline-4">
<h4 id="sec-3-4-7"><span class="section-number-4">3.4.7</span> Scriviamo i nostri metodi, altrimenti a che serve?</h4>
<div class="outline-text-4" id="text-3-4-7">
<p>
Fino ad adesso abbiamo visto a grandi linee cosa sono i metodi e ne abbiamo usati alcuni.
I metodi, si possono <i>definire</i> come le <i>variabili</i>. Altrimenti potremmo anche andare a coltivale le cipolle (che sono buone e le adoro anche crude nell'insalata).
</p>

<p>
Come si fa a definire un metodo? Per prima cosa decidiamo un bel nome, un nome importante&#x2026; Soprattutto un nome che dica cosa fa, per ricordarlo meglio.
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-keyword">def</span> <span class="org-function-name">somma</span>(x, y)
  x + y
<span class="org-keyword">end</span>
</pre>
</div>

<p>
Abbiamo definito un metodo che prende due valori in <i>input</i>, <i>x</i> ed <i>y</i>, che si chiama <i>somma</i>.
Lo possiamo usare così:
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-keyword">def</span> <span class="org-function-name">somma</span>(x, y)
  x + y
<span class="org-keyword">end</span>

risultato = somma(2, 3)

<span class="org-builtin">puts</span> risultato
</pre>
</div>

<p>
Fate nell'editor, salvate come <i>metodi.rb</i> ed eseguite. Vedrete il risultato di <i>2 + 3</i>.
Invece di assegnare il valore di ritorno del metodo ad una variabile, in questo caso avreste anche potuto scrivere:
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-builtin">puts</span> somma(2, 3)
</pre>
</div>

<p>
Ricordate? <i>puts</i> è un metodo, quindi vuol dire che noi possiamo passare un metodo ad un altro metodo come suo parametro in <i>input</i>.
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-builtin">puts</span> somma(somma(2, 3), 5)
</pre>
</div>

<p>
Che farà? Quanto farà? Chi lo sa? Al primo che risponde niente compiti.
</p>


<p>
I metodi, come abbiamo già visto, servono per scrivere delle istruzioni che poi possiamo riutilizzare. Pensate se ogni volta dovessimo riscrivere le stesse cose.
Programmare è spesso un lavoro ripetitivo e potenzialmente si scrivono le stesse cose centinaia se non migliaia di volte.
Senza i metodi (almeno quelli) saremmo perduti (anche se pensate esistono linguaggi che non li hanno).
</p>

<p>
I metodi sono raggruppati in <i>librerie</i> generalmente, anche Ruby ha le sue <i>librerie</i>. Insomma i metodi sono come delle parole o meglio dei capitoli dentro dei libri, che sono sugli scaffali di una libreria. È importante ricordare questo perché vedremo in seguito che per chiamare un metodo dobbiamo trovarlo come un libro nello scaffale: <i>scaffale_destro::libro_primo.capitolo_secondo</i>.
</p>

<p>
Trasformiamo il codice per scrivere la tabella pitagorica come metodo:
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">prepara una tabella (array bidimensionale)</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">con i valori</span>
<span class="org-keyword">def</span> <span class="org-function-name">tabella_pitagorica</span>(numeri)
  numeri.map { |numero|
    numeri.map { |moltiplicatore| 
      numero * moltiplicatore
    }
  }
<span class="org-keyword">end</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">stampa un array bidimensionale</span>
<span class="org-keyword">def</span> <span class="org-function-name">stampa_tabella</span>(tabella)
  <span class="org-builtin">puts</span> (tabella.map { |riga| 
    (riga.map {|numero| 
      numero.to_s + (numero &lt; 10 ? <span class="org-string">'  '</span> : <span class="org-string">' '</span>)
    }).join
  }).join(<span class="org-string">"\n"</span>)
<span class="org-keyword">end</span>

stampa_tabella(tabella_pitagorica([1,2,3,4,5,6,7,8,9,10]))
</pre>
</div>

<p>
Al solito salviamo, come <i>metodi1.rb</i> ed eseguiamo.
</p>

<div class="org-src-container">

<pre class="src src-sh">&#10140;  source  ruby metodi2.rb
1  2  3  4  5  6  7  8  9  10 
2  4  6  8  10 12 14 16 18 20 
3  6  9  12 15 18 21 24 27 30 
4  8  12 16 20 24 28 32 36 40 
5  10 15 20 25 30 35 40 45 50 
6  12 18 24 30 36 42 48 54 60 
7  14 21 28 35 42 49 56 63 70 
8  16 24 32 40 48 56 64 72 80 
9  18 27 36 45 54 63 72 81 90 
10 20 30 40 50 60 70 80 90 100 
&#10140;  source
</pre>
</div>

<p>
Come vedete il risultato è quello. Adesso abbiamo un metodo chiamato <i>tabella_pitagorica</i> che prenderà in <i>input</i> come <i>parametro</i> un array di numeri e costruirà un array di array di numeri.
</p>

<div class="org-src-container">

<pre class="src src-ruby">[[1,2,3,4,5,6,7,8,9],[2,4,6,8,10,12,14,16,18,20], [3,6,9,12,15,18,21,24,27,30], ...]
</pre>
</div>

<p>
L'altro metodo, <i>stampa_tabella</i>, prende in entrata un <i>array bidimensionale</i> (la tabella coi valori) e lo stampa in <i>output</i>.
La cosa interessante è che <i>stampa_tabella</i> stampa in quel modo, qualunque <i>array bidimensionale</i> e non solo la nostra tabella pitagorica.
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">stampa un array bidimensionale</span>
<span class="org-keyword">def</span> <span class="org-function-name">stampa_tabella</span>(tabella)
  <span class="org-builtin">puts</span> (tabella.map { |riga| 
    (riga.map {|numero| 
      numero.to_s + (numero &lt; 10 ? <span class="org-string">'  '</span> : <span class="org-string">' '</span>)
    }).join
  }).join(<span class="org-string">"\n"</span>)
<span class="org-keyword">end</span>

stampa_tabella([[1,10,30,4,50,6,7,8,9,0,9,0],[2,4,6,81,17,12,14,1,1,2], [3,6,9,12,15,18,21,24,27,30]])
</pre>
</div>

<p>
Salvate come <i>metodi3.rb</i> ed eseguite:
</p>

<div class="org-src-container">

<pre class="src src-sh">&#10140;  source  ruby metodi3.rb
1  10 30 4  50 6  7  8  9  0  9  0  
2  4  6  81 17 12 14 1  1  2  
3  6  9  12 15 18 21 24 27 30 
&#10140;  source
</pre>
</div>

<p>
I metodi possono avere più parametri ma come consiglio limitatevi al meno possibile.
</p>
</div>
</div>
</div>


<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5"><span class="section-number-3">3.5</span> Le cose serie</h3>
<div class="outline-text-3" id="text-3-5">
<p>
Ora cominceremo ad affrontare alcune delle caratteristiche di Ruby che ne fanno un linguaggio agile moderno.
</p>
</div>

<div id="outline-container-sec-3-5-1" class="outline-4">
<h4 id="sec-3-5-1"><span class="section-number-4">3.5.1</span> Raggruppiamo i metodi in moduli</h4>
<div class="outline-text-4" id="text-3-5-1">
<p>
Ruby è un linguaggio estremamente <i>modularizzabile</i> il che significa che ha numerosi modi di riutilizzare le cose già scritte. Questo ne fa un linguaggio molto adatto al lavoro in collaborazione, cioè tra più persone che lavorano a parti diverse del <i>codice</i>.
</p>

<p>
Uno dei meccanismi di <i>raggruppamento</i> sono i <i>moduli</i>:
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-keyword">module</span> <span class="org-type">Pippo</span>

  <span class="org-keyword">def</span> <span class="org-function-name">dice</span>(cosa)
    <span class="org-builtin">puts</span> cosa
  <span class="org-keyword">end</span>

<span class="org-keyword">end</span>
</pre>
</div>

<p>
I <i>moduli</i> sono dei <i>contesti</i> dove i metodi (ed altre cose) vivono.
Prima però di usare i <i>metodi</i> di un modulo, dobbiamo <i>includerlo</i>. Avete presente quando un amichetto viene a casa vostra e giocate insieme? Uguale.
Dovete prima <i>invitare</i> il modulo nel vostro <i>contesto</i>. A casa vostra, insomma.
</p>


<div class="org-src-container">

<pre class="src src-ruby"><span class="org-keyword">module</span> <span class="org-type">Pippo</span>

  <span class="org-keyword">def</span> <span class="org-function-name">dice</span>(cosa)
    <span class="org-builtin">puts</span> <span class="org-string">"Pippo dice: "</span> + cosa
  <span class="org-keyword">end</span>

<span class="org-keyword">end</span>

<span class="org-builtin">include</span> <span class="org-type">Pippo</span>

dice(<span class="org-string">"ciao"</span>)
</pre>
</div>

<p>
Salvate come <i>moduli.rb</i> ed eseguite, vedrete che scriverà: <i>Pippo dice ciao</i>.
Avete invitato il modulo <i>Pippo</i> nel vostro <i>contesto</i> con la <i>parola chiave</i> (<i>keyword</i>) <i>include</i>. Da lì in poi potete usare il metodo <i>dice</i> semplicemente. Se non includete il modulo, Ruby si lamenterà dicendo che non trova il metodo <i>ciao</i>
</p>

<div class="org-src-container">

<pre class="src src-sh">&#10140;  source  ruby moduli.rb
moduli.rb:20:in <span class="org-sh-quoted-exec">`&lt;main&gt;': undefined method `</span>dice<span class="org-string">' for main:Object (NoMethodError)</span>
<span class="org-string">&#10140;  source</span>
</pre>
</div>

<p>
Includere un modulo significa <i>copiare i metodi del modulo nel contesto dove si include</i>, questo può sembrare difficile ma non lo è (non molto almeno) ed ha delle conseguenze.
</p>


<div class="org-src-container">

<pre class="src src-ruby"><span class="org-keyword">module</span> <span class="org-type">Pippo</span>

  <span class="org-keyword">def</span> <span class="org-function-name">dice</span>(cosa)
    <span class="org-builtin">puts</span> <span class="org-string">"Pippo dice: "</span> + cosa
  <span class="org-keyword">end</span>

<span class="org-keyword">end</span>

<span class="org-keyword">module</span> <span class="org-type">Pluto</span>

  <span class="org-keyword">def</span> <span class="org-function-name">dice</span>(cosa)
    <span class="org-builtin">puts</span> <span class="org-string">"Pluto dice: "</span> + cosa
  <span class="org-keyword">end</span>

<span class="org-keyword">end</span>

<span class="org-builtin">include</span> <span class="org-type">Pippo</span>
<span class="org-builtin">include</span> <span class="org-type">Pluto</span>

dice(<span class="org-string">"ciao"</span>)
</pre>
</div>

<p>
Salvate come <i>moduli2.rb</i> ed eseguite:
</p>

<div class="org-src-container">

<pre class="src src-sh">&#10140;  source  ruby moduli2.rb
Pluto dice: ciao
&#10140;  source
</pre>
</div>

<p>
Il problema è: quale metodo <i>dice</i> viene chiamato? Come vedete è quello di <i>Pluto</i> perché il modulo <i>Pluto</i> è incluso dopo il modulo <i>Pippo</i>.
Ci sono varie implicazioni in questo comprese delle cose <i>strane</i>:
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-keyword">module</span> <span class="org-type">Pippo</span>

  <span class="org-keyword">def</span> <span class="org-function-name">dice</span>(cosa)
    <span class="org-builtin">puts</span> <span class="org-string">"Pippo dice: "</span> + cosa
  <span class="org-keyword">end</span>

<span class="org-keyword">end</span>

<span class="org-keyword">module</span> <span class="org-type">Pluto</span>

  <span class="org-keyword">def</span> <span class="org-function-name">dice</span>(cosa)
    <span class="org-builtin">puts</span> <span class="org-string">"Pluto dice: "</span> + cosa
  <span class="org-keyword">end</span>

<span class="org-keyword">end</span>

<span class="org-builtin">include</span> <span class="org-type">Pippo</span>
<span class="org-builtin">include</span> <span class="org-type">Pluto</span>

<span class="org-type">Pippo</span>.dice(<span class="org-string">"ciao"</span>)
<span class="org-type">Pippo</span>::dice(<span class="org-string">"ciao"</span>)
</pre>
</div>

<p>
Salvate come <i>moduli3.rb</i> ed eseguite:
</p>

<div class="org-src-container">

<pre class="src src-sh">&#10140;  source  ruby moduli3.rb
Pluto dice: ciao
Pluto dice: ciao
&#10140;  source
</pre>
</div>

<p>
Come si può vedere anche usando gli operatori di visibilità di Ruby <i>::</i> o . non si riesce ad invocare il <i>dice</i> racchiuso dentro <i>Pippo</i>. Questo è spiegabile ma non adesso.
Per ora ricordate che: <b>se includete un modulo i metodi di questo sono <i>copiati</i> dove li avete inclusi e che i metodi con lo stesso nome e lista di prametri si <i>sovrascrivono</i></b>.
</p>

<p>
Adesso vediamo come rendere un modulo una libreria.
</p>

<p>
Scrivete e salvate questi due file, il primo chiamatelo <i>pippo.rb</i> ed il secondo <i>moduli4.rb</i>.
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-keyword">module</span> <span class="org-type">Pippo</span>

  <span class="org-keyword">def</span> <span class="org-function-name">dice</span>(cosa)
    <span class="org-builtin">puts</span> <span class="org-string">"Pippo dice: "</span> + cosa
  <span class="org-keyword">end</span>

<span class="org-keyword">end</span>
</pre>
</div>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-builtin">require</span> <span class="org-string">'./pippo'</span>

<span class="org-builtin">include</span> <span class="org-type">Pippo</span>

dice(<span class="org-string">"ciao"</span>)
</pre>
</div>

<p>
Eseguite <i>moduli4.rb</i>:
</p>

<div class="org-src-container">

<pre class="src src-sh">&#10140;  source  ruby moduli4.rb
Pippo dice: ciao
&#10140;  source
</pre>
</div>

<p>
Abbiamo trasformato il modulo <i>Pippo</i> in una libreria. Potete mettere quello che volete dentro il file della libreria e chiamarlo come volete.
Lo dovete prima <i>richiedere</i> con la <i>keyword</i> <b><i>require</i></b> ed il percorso nel <i>file system</i> del file. La sintassi del percorso segue lo standard <i>Unix</i> quindi non avete come su Microsoft Windows<sup>tm</sup> le barre rovesciate <code>\</code> ma invece avete le barre normali <code>/</code>.
</p>

<p>
In questo caso, require './pippo', significa: <i>richiedi il file pippo.rb che si trova nella cartella corrente</i>. Una volta richiesto, il file potrà essere usato come se il suo codice fosse scritto direttamente.
</p>

<p>
Il dividere un programma in più file, consente di riutilizzare il <i>codice</i> scritto in precedenza da noi o da altri e di averne anche una organizzazione <i>spaziale</i> (e non parlo di astronavi). 
</p>
</div>
</div>

<div id="outline-container-sec-3-5-2" class="outline-4">
<h4 id="sec-3-5-2"><span class="section-number-4">3.5.2</span> Le classi (non quelle della scuola, o forse si?)</h4>
<div class="outline-text-4" id="text-3-5-2">
<p>
Cominciamo a vedere le <i>classi</i>, questi <i>oggetti</i> misteriosi. Non ha caso ho detto <i>classi</i> e <i>oggetti</i>.
</p>

<p>
Ruby è un <i>linguaggio di programmazione Object Oriented</i>, l'ho già detto prima. Ricordate?
</p>

<p>
Vuol dire: <i>linguaggio di programmazione orientato agli oggetti</i>. 
Che vuol dire: <i>un linguaggio di programmazione in cui gli oggetti sono la cosa più importante</i>.
Che vuol dire: <i>un linguaggio di programmazione dove si usano delle descrizioni degli oggetti, chiamate classi, per modellare il dominio del problema</i>.
Continuo? - Sempre più difficile, Signore e Signori! - <br >
</p>

<p>
Facciamola semplice e partiamo da qualche esempio.
</p>

<p>
Intorno a noi ci sono tante cose, pensateci bene. Imparare a programmare i computer <i>fa bene</i> anche perché insegna a ragionare e ad affrontare i problemi in maniera <i>analitica</i>.
Insomma, intorno a noi abbiamo tante cose: viviamo dentro delle <i>case</i>, guardiamo il <i>televisore</i>, ascoltiamo la musica col <i>giradischi</i> (che voi forse non sapete nemmeno cosa sia, ma io sono vecchio e lo so), camminiamo con le scarpe, ci mettiamo i <i>pantaloni</i> e ci sediamo sulla <i>sedia</i>, leggiamo <i>libri</i>&#x2026; Potrei continuare all'infinito.
</p>

<p>
Intorno a noi ci sono oggetti. Questi oggetti servono a qualcosa, fanno qualcosa o subiscono qualcosa.
Gli oggetti possono essere formati da altri oggetti, ricordate quando prima ho detto dei mattoncini Lego<sup>(tm)</sup>?
Il Meccano<sup>(tm)</sup>, quando ero piccolo c'era questo, oggetti in metallo, viti e bulloni, motori elettrici&#x2026;
Ci ho costruito tante cose.
Chi di voi è uno <i>smontatore</i> professionista? Io da piccolo smontavo praticamente tutto: volevo vedere come funzionasse dentro.
</p>

<p>
Con i linguaggi di programmazione avete gli <i>strumenti per scatenare la curiosità</i>, se volete.
Ritorniamo ai nostri oggetti ed alla definizione di un <i>linguaggio di programmazione orientato agli oggetti</i> (come è Ruby, che però non è solo questo): <br >
</p>

<p>
<b>è un linguaggio che permette di descrivere il <i>dominio del problema</i> definendo gli oggetti che lo compongono e le loro interazioni</b> <br >
</p>

<p>
Il <i>dominio del problema</i> significa solo <i>quello che volete fare</i>, perché usare delle parole difficili? Primo è perché vogliamo imparare le <i>parole giuste</i>, secondo perché, in realtà, c'è di più di <i>quello che volete fare</i>.
Per adesso però, va bene così.
</p>

<p>
Per <i>fare quello che volete fare</i> dovete analizzare tutti i piccoli pezzi che compongono o servono per <i>fare quello che volete fare</i>. Tra un po' comincio con gli scioglilingua&#x2026; <br >
</p>

<p>
Ma cosa <i>volete fare?</i>. <br >
</p>

<p>
Pensate alla macchina, che poi si dice <i>automobile</i>&#x2026; Anche se è una <i>macchina</i>. Elenchiamo i pezzi che la compongono: sedili, sportelli, volante, ruote, vetri, ingranaggi, motore, viti, bulloni e <i>chi più ne ha ne metta</i>&#x2026;
</p>

<p>
Ho puntualizzato che l'<i>automobile</i> è una <i>macchina</i> e vedrete che questa affermazione banale, così semplice, ha una sua ragione di esistere.
</p>

<p>
Cominciamo a descrivere meglio una automobile e facciamolo in Ruby.
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Automobile</span>

<span class="org-keyword">end</span>
</pre>
</div>

<p>
Abbiamo definito una <i>classe</i> e cioè una <i>classe di oggetti</i>. La <i>classe</i> (<i>class</i>) è la descrizione dell'oggetto con le sue <i>proprietà</i> o <i>attributi</i> (gli oggetti che la compongono) ed i <i>metodi</i> che sono il come interagisce col mondo esterno, cosa fa o cosa subisce.
</p>

<p>
L'automobile ha le ruote prima di tutto:
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Automobile</span>

  <span class="org-variable-name">@ruote</span> = 4

<span class="org-keyword">end</span>
</pre>
</div>

<p>
<i>@ruote</i> si chiama <i>variabile di istanza</i>. È una <i>variabile</i> come le abbiamo già viste, ma vive dentro un <i>oggetto</i> che sarebbe una <i>istanza di una classe</i>. <br >
Le <i>variabili di istanza</i> cominciano per <i>@</i>.
</p>

<p>
Ricapitoliamo:
</p>

<ul class="org-ul">
<li>la <i>classe</i> descrive l'<i>oggetto</i> nella sua forma e funzione
</li>
<li>l'<i>istanza</i> rende <i>viva</i> la <i>classe</i> come <i>oggetto</i>
</li>
</ul>

<p>
Una <i>variabile di istanza</i> non è ancora un <i>attributo</i>, anche se ancora non sappiamo cosa significhi un <i>attributo</i>.
Per farla semplice, diciamo che una <i>classe</i> ha delle parti nascoste e delle parti visibili, l'<i>automobile</i> ha di visibile la carrozzeria ma non il motore. Per vedere quello dovete aprire il cofano, guardare dentro.
È la stessa cosa, una classe in Ruby ha delle parti nascoste e delle parti visibili: <i>@ruote</i> è ancora nascosta.
Direi anche di lasciarla nascosta, mica vogliamo che mentre siamo in corsa a duecento chilometri all'ora verso una curva ci cambino il numero delle ruote? Se di punto in bianco diventano tre? O due? o Niente?
</p>

<p>
Lasciamola nascosta <i>che è meglio</i> (citazione dai Puffi).
Però, il numero delle persone potrebbe cambiare no?
</p>

<p>
Aggungiamo le persone, le auto portano le persone:
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Automobile</span>

  <span class="org-variable-name">@ruote</span> = 4
  <span class="org-builtin">attr_accessor</span> <span class="org-constant">:persone</span>

<span class="org-keyword">end</span>
</pre>
</div>

<p>
Ora noi abbiamo che <i>persone</i> è <i>accessibile</i> e si vede dall'esterno dell'oggetto.
</p>

<div class="org-src-container">

<pre class="src src-ruby">irb(main)<span class="org-constant">:001</span>:0&gt; <span class="org-keyword">class</span> <span class="org-type">Automobile</span>
irb(main)<span class="org-constant">:002</span>:1&gt; <span class="org-variable-name">@ruote</span> = 4
irb(main)<span class="org-constant">:003</span>:1&gt; <span class="org-builtin">attr_accessor</span> <span class="org-constant">:persone</span>
irb(main)<span class="org-constant">:004</span>:1&gt; <span class="org-keyword">end</span>
=&gt; <span class="org-variable-name">nil</span>
irb(main)<span class="org-constant">:005</span>:0&gt; <span class="org-type">Auto</span> = <span class="org-type">Automobile</span>.new
=&gt; <span class="org-comment-delimiter">#</span><span class="org-comment">&lt;Automobile:0x007f8995f94a90&gt;</span>
irb(main)<span class="org-constant">:006</span>:0&gt; <span class="org-type">Auto</span>.persone = 4
=&gt; 4
irb(main)<span class="org-constant">:007</span>:0&gt; <span class="org-type">Auto</span>.persone
=&gt; 4
irb(main)<span class="org-constant">:008</span>:0&gt;
</pre>
</div>

<p>
Ho rifatto il codice dentro <i>irb</i> per farvi vedere? Capito?
L'<i>attributo</i> <i>persone</i> è visibile dal'esterno dell'oggetto. Analizziamo il codice meglio.
</p>

<p>
Dopo aver definito la classe <i>Automobile</i> ho costruito l'oggetto <i>Automobile</i> con il metodo <i>new</i> (<i>nuovo</i>). Si dice che <i>ho istanziato la classe</i>.
L'<i>oggetto</i> appena creato l'ho immagazzinato dentro una variabile che ho chiamato <i>Auto</i>.
</p>

<p>
Cominciamo a capire cosa è la <i>classe</i>? La <i>classe</i> è come il <i>progetto</i> di un oggetto, che poi va costruito. Infatti nel gergo dei linguaggi di programmazione orientati agli oggetti, metodi come <i>new</i> sono chiamati <i>costruttori</i> (anche se con Ruby è impreciso e sarebbe meglio chiamarlo <i>metodo istanziatore</i>).
</p>

<div class="org-src-container">

<pre class="src src-ruby">irb(main)<span class="org-constant">:005</span>:0&gt; <span class="org-type">Auto</span> = <span class="org-type">Automobile</span>.new
=&gt; <span class="org-comment-delimiter">#</span><span class="org-comment">&lt;Automobile:0x007f8995f94a90&gt;</span>
</pre>
</div>

<p>
Quello che vedete sotto ad <i>Auto = Automobile.new</i> è il nome dell'istanza della classe <i>Automobile</i> che ho appena creato. Il nome vero, ma noi ci riferiremo a questa con <i>Auto</i>.
</p>

<p>
Adesso cerco di cambiare il numero delle persone e quello delle ruote:
</p>

<div class="org-src-container">

<pre class="src src-ruby">irb(main)<span class="org-constant">:009</span>:0&gt; <span class="org-type">Auto</span>.persone
=&gt; 4
irb(main)<span class="org-constant">:010</span>:0&gt; <span class="org-type">Auto</span>.persone = 5
=&gt; 5
irb(main)<span class="org-constant">:011</span>:0&gt; <span class="org-type">Auto</span>.ruote = 2
<span class="org-type">NoMethodError</span>: undefined method <span class="org-string">`ruote=' for #&lt;Automobile:0x007f8995f94a90 @persone=5&gt;</span>
<span class="org-string">        from (irb):11</span>
<span class="org-string">        from /home/nissl/bin/ruby-2.1/bin/irb:11:in `</span>&lt;main&gt;<span class="org-string">'</span>
<span class="org-string">irb(main):012:0&gt;</span>
</pre>
</div>

<p>
Sono riuscito a farlo per le <i>persone</i> ma non per le <i>ruote</i>. L'<i>attributo</i> <i>persone</i> è visibile all'esterno e si può cambiare: è <i>accessibile in lettura e scrittura</i>; <i>ruote</i> no.
</p>

<p>
Ruby però, in certe cose è davvero strano ed è nella sua natura esserlo. In Ruby <i>tutto è un oggetto</i>.
</p>

<p>
Non vorrei complicarvi la vita troppo, e la faccio breve con un esempio:
</p>

<div class="org-src-container">

<pre class="src src-ruby">irb(main)<span class="org-constant">:017</span>:0&gt; <span class="org-type">Auto</span>.instance_variables
=&gt; [<span class="org-constant">:@persone</span>]
irb(main)<span class="org-constant">:018</span>:0&gt; <span class="org-type">Automobile</span>.instance_variables
=&gt; [<span class="org-constant">:@ruote</span>, <span class="org-constant">:@persone</span>]
irb(main)<span class="org-constant">:019</span>:0&gt;
</pre>
</div>

<p>
Ho invocato il metodo <i>instance_variables</i> (che mi elenca dentro un array le variabili di istanza di un oggetto) sull'oggetto <i>Auto</i> e sulla classe <i>Automobile</i> e&#x2026; <i>Auto</i> ha <b>una</b> variabile di istanza mentre Automobile ne ha due.
Automobile ha due variabili di istanza? Finora vi ho detto che Automobile non era una <i>istanza</i> ma una <i>classe</i>! Vi ho perso in giro? No, non l'ho fatto ma non sono stato preciso.
In Ruby, tutto è un oggetto, anche le <i>classi</i>. Questo porta ad interessanti implicazioni e possibilità del linguaggio che però vanno oltre lo scopo di questo piccolo corso.
</p>

<p>
Sappiate questo: se vogliamo utilizzare una variabile di istanza dentro una istanza dobbiamo scriverla in un altro modo.
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Automobile</span>  

  <span class="org-builtin">attr_reader</span> <span class="org-constant">:ruote</span>
  <span class="org-builtin">attr_accessor</span> <span class="org-constant">:persone</span>

  <span class="org-keyword">def</span> <span class="org-function-name">initialize</span>
    <span class="org-variable-name">@ruote</span> = 4
  <span class="org-keyword">end</span>

<span class="org-keyword">end</span>
</pre>
</div>

<p>
Ho aggiunto <i>attr_reader</i> ed un metodo importantissimo: <i>initialize</i>.
Il metodo <i>inizialize</i> viene invocato automaticamente da Ruby quando usiamo il metodo <i>costruttore</i> <i>new</i>. Il nome stesso spiega cosa fa: <i>inizializza l'istanza</i>; cioè fa qualcosa mentre l'oggetto è preparato per essere usato.
Le variabili di istanza di un oggetto devono essere definite e dichiarate qui dentro se le vogliamo avere disponibili alla creazione.
La dichiarazione <i>attr_reader :ruote</i> dice che la variabile di istanza <i>@ruote</i> sarà solo disponibile in lettura.
</p>

<p>
Questi i dichiaratori di accesso delle variabili di istanza:
</p>

<ul class="org-ul">
<li><b>attr_reader</b>, accesso in sola lettura
</li>
<li><b>attr_writer</b>, accesso in sola scrittura
</li>
<li><b>attr_accessor</b>, accesso in lettura e scrittura
</li>
</ul>

<p>
Questi dichiaratori, sono dei metodi di <i>convenienza</i> se non usassi <i>attr_accessor</i> dovrei scrivere così:
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Automobile</span>  

  <span class="org-keyword">def</span> <span class="org-function-name">initialize</span>
    <span class="org-variable-name">@ruote</span> = 4
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">persone</span>
    <span class="org-variable-name">@persone</span>
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">persone=</span>(numero)
    <span class="org-variable-name">@persone</span> = numero
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">ruote</span>
    <span class="org-variable-name">@ruote</span>
  <span class="org-keyword">end</span>

<span class="org-keyword">end</span>
</pre>
</div>

<p>
Come vedete ho scritto di più di prima ed il codice è meno leggibile e più complicato.
Ruby ha molti <i>metodi di convenienza</i> (detti <i>helpers</i>) quindi usateli.
</p>

<p>
Cerchiamo di migliorare la nostra Automobile. In fondo, scusate cosa è una Automobile? È un veicolo a motore&#x2026; Invece un veicolo a motore non è un generico veicolo?
Un'altra cosa interessante dei linguaggi di programmazione orientati agli oggetti è che supportano l'<i>ereditarietà</i>.
Avete presente voi ed i vostri genitori? A chi assomigliate? Da chi avete <i>ereditato</i> il naso o gli occhi?
</p>

<p>
Partendo da un generico <i>Veicolo</i> andiamo verso un <i>Veicolo a motore</i> e poi ad una <i>Automobile</i>. <br >
</p>

<p>
<b>Veicolo -&gt; VeicoloAMotore -&gt; Automobile</b> <br >
</p>

<p>
Scrivete e salvate questo file come <i>automobile.rb</i>.
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Veicolo</span>
<span class="org-keyword">end</span>

<span class="org-keyword">class</span> <span class="org-type">VeicoloAMotore</span> &lt; <span class="org-type">Veicolo</span>

  <span class="org-builtin">attr_reader</span> <span class="org-constant">:motore</span>

  <span class="org-keyword">def</span> <span class="org-function-name">initialize</span>
    <span class="org-variable-name">@motore</span> = <span class="org-variable-name">true</span>
  <span class="org-keyword">end</span>

<span class="org-keyword">end</span>

<span class="org-keyword">class</span> <span class="org-type">VeicoloARuoteConMotore</span> &lt; <span class="org-type">VeicoloAMotore</span>

  <span class="org-builtin">attr_reader</span> <span class="org-constant">:ruote</span>

  <span class="org-keyword">def</span> <span class="org-function-name">initialize</span>(numero_ruote = 4)
    <span class="org-keyword">super</span>()
    <span class="org-variable-name">@ruote</span> = numero_ruote
  <span class="org-keyword">end</span>

<span class="org-keyword">end</span>

<span class="org-keyword">class</span> <span class="org-type">Automobile</span> &lt; <span class="org-type">VeicoloARuoteConMotore</span>

  <span class="org-builtin">attr_accessor</span> <span class="org-constant">:persone</span>

  <span class="org-keyword">def</span> <span class="org-function-name">initialize</span>
    <span class="org-keyword">super</span>(4)
    <span class="org-variable-name">@persone</span> = 0
  <span class="org-keyword">end</span>

<span class="org-keyword">end</span>

<span class="org-type">Auto</span> = <span class="org-type">Automobile</span>.new

<span class="org-type">Auto</span>.persone = 5

<span class="org-builtin">puts</span> <span class="org-string">"Auto ha il motore: "</span> + (<span class="org-type">Auto</span>.motore ? <span class="org-string">"si"</span> : <span class="org-string">"no"</span>)
<span class="org-builtin">puts</span> <span class="org-string">"Ospita quante persone? "</span> + <span class="org-type">Auto</span>.persone.to_s
<span class="org-builtin">puts</span> <span class="org-string">"Quante ruote? "</span> + <span class="org-type">Auto</span>.ruote.to_s
puts
<span class="org-builtin">puts</span> <span class="org-string">"Variabili di istanza sono:"</span>
<span class="org-builtin">puts</span> <span class="org-type">Auto</span>.instance_variables
</pre>
</div>

<p>
Se lo fate girare:
</p>

<div class="org-src-container">

<pre class="src src-sh">&#10140;  source  ruby automobile.rb
Auto ha il motore: si
Ospita quante persone? 5
Quante ruote? 4

Variabili di istanza sono:
@motore
@ruote
@persone
&#10140;  source
</pre>
</div>

<p>
Abbiamo creato la nostra prima gerarchia di <i>classi</i>. <br >
</p>

<p>
Come vedete: <b>Veicolo -&gt; VeicoloAMotore -&gt; VeicoloARuoteConMotore -&gt; Automobile</b>. <br >
</p>

<p>
Ogni classe ha un <i>initialize</i> che noi dovremmo richiamare nella <i>classe derivata</i> per essere sicuri che il <i>genitore</i> sia <i>inizializzato</i> a dovere. Questo si fa con <i>super</i>.
Il metodo <i>super</i> si assicura di richiamare il metodo <i>inizialize</i> del padre, infatti noi dobbiamo scriverlo e passargli eventuali parametri.
Il suo funzionamento è <i>abbastanza magico</i> nel senso che i parametri dell'<i>initialize</i> del figlio vengo passati automaticamente a <i>super</i>. Per questo motivo nella classe <i>VeicoloARuoteConMotore</i> è scritto <i>super()</i>, per evitare che a <i>inizialize</i> del genitore venga passato un parametro che non è richiesto.
Questo sarebbe stato l'errore:
</p>

<div class="org-src-container">

<pre class="src src-sh">&#10140;  source  ruby automobile.rb
automobile.rb:8:in <span class="org-sh-quoted-exec">`initialize': wrong number of arguments (1 for 0) (ArgumentError)</span>
<span class="org-sh-quoted-exec">        from automobile.rb:19:in `</span>initialize<span class="org-string">'</span>
<span class="org-string">        from automobile.rb:30:in `initialize'</span>
        from automobile.rb:36:in <span class="org-sh-quoted-exec">`new'</span>
<span class="org-sh-quoted-exec">        from automobile.rb:36:in `</span>&lt;main&gt;<span class="org-string">'</span>
<span class="org-string">&#10140;  source</span>
</pre>
</div>

<p>
Dimenticavo, come forse avete notato il metodo <i>initialize</i> della classe <i>VeicoloARuoteConMotore</i> è così: <i>def initialize(numero_ruote = 4)</i>. In Ruby i parametri possono avere dei valori già impostati (di <i>default</i>) e ciò permette di ometterli quando si invoca un metodo. Non abusate di questa <i>facilitazione</i> può essere molto pericolosa.
</p>

<p>
So di essere stato <i>contorto</i> ma non è semplice da spiegare. Dovete riflettere bene su questo e cercare di capire.
Ruby ha, come già detto altre volte, delle cose che sembrano a prima vista <i>strane</i>, ma vedrete che invece sono la sua <i>forza</i>.
</p>


<p>
Cambiamo le classi però, che così non vanno tanto bene:
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Veicolo</span>
<span class="org-keyword">end</span>

<span class="org-keyword">class</span> <span class="org-type">VeicoloAMotore</span> &lt; <span class="org-type">Veicolo</span>

  <span class="org-variable-name">@@motore</span> = <span class="org-variable-name">true</span>

  <span class="org-keyword">def</span> <span class="org-function-name">motore</span>
    <span class="org-variable-name">@@motore</span>
  <span class="org-keyword">end</span>

<span class="org-keyword">end</span>

<span class="org-keyword">class</span> <span class="org-type">VeicoloARuoteConMotore</span> &lt; <span class="org-type">VeicoloAMotore</span>

  <span class="org-keyword">def</span> <span class="org-function-name">initialize</span>(numero_ruote = 4)
    <span class="org-variable-name">@@ruote</span> = numero_ruote
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">ruote</span>
    <span class="org-variable-name">@@ruote</span>
  <span class="org-keyword">end</span>

<span class="org-keyword">end</span>

<span class="org-keyword">class</span> <span class="org-type">Automobile</span> &lt; <span class="org-type">VeicoloARuoteConMotore</span>

  <span class="org-builtin">attr_accessor</span> <span class="org-constant">:persone</span>

  <span class="org-keyword">def</span> <span class="org-function-name">initialize</span>
    <span class="org-keyword">super</span>(4)
    <span class="org-variable-name">@persone</span> = 0
  <span class="org-keyword">end</span>

<span class="org-keyword">end</span>

<span class="org-type">Auto</span> = <span class="org-type">Automobile</span>.new

<span class="org-type">Auto</span>.persone = 5

<span class="org-builtin">puts</span> <span class="org-string">"Auto ha il motore: "</span> + (<span class="org-type">Auto</span>.motore ? <span class="org-string">"si"</span> : <span class="org-string">"no"</span>)
<span class="org-builtin">puts</span> <span class="org-string">"Ospita quante persone? "</span> + <span class="org-type">Auto</span>.persone.to_s
<span class="org-builtin">puts</span> <span class="org-string">"Quante ruote? "</span> + <span class="org-type">Auto</span>.ruote.to_s
puts
<span class="org-builtin">puts</span> <span class="org-string">"Variabili di istanza sono:"</span>
<span class="org-builtin">puts</span> <span class="org-type">Auto</span>.instance_variables
</pre>
</div>

<p>
Ho scritto delle variabili con due <i>@</i> (<i>@@</i>).
Queste sono <i>variabili di classe</i> e si propagano per tutta la gerarchia degli oggetti. La differenza tra le <i>class variables</i> e le <i>instance variables</i> è che le seconde nelle istanze figlie sono delle copie, la prime le stesse.
</p>

<p>
Esempio: due bambini comprano due cacciaviti sonici del Doctor Who, oppure ne comprano uno solo e se lo passano.
Nel primo caso, se uno si rompe, è solo quel bambino a piangere. Nel secondo piangono tutti e due.
</p>

<p>
Chiaro?
</p>

<p>
Classi ne abbiamo molte in Ruby, già di suo. <i>Array</i> è una classe, <i>Fixnum</i> un'altra, <i>String</i>. Abbiamo poi una classe <i>Time</i> per gestire il tempo o <i>Hash</i> che è importantissima.
Ce ne sono davvero tante:
</p>

<ul class="org-ul">
<li>La documentazione base: <a href="http://www.ruby-doc.org/core-2.1.3/">http://www.ruby-doc.org/core-2.1.3/</a>
</li>
<li>La documentazione della libreria: <a href="http://www.ruby-doc.org/stdlib-2.1.3/">http://www.ruby-doc.org/stdlib-2.1.3/</a>
</li>
</ul>

<p>
Ruby ha una libreria molto estesa per fare davvero molte cose.
Oltre alla sua, ha un sistema di gestione delle librerie che si chiama: <i>RubyGems</i>, <a href="https://rubygems.org/">https://rubygems.org/</a>; dove sono reperibili migliaia di ulteriori librerie.
Oltre a questo ne scriverete anche di vostre, no?
</p>
</div>
</div>

<div id="outline-container-sec-3-5-3" class="outline-4">
<h4 id="sec-3-5-3"><span class="section-number-4">3.5.3</span> Blocks e Procs, che non è il Rock'n'Roll ma ci si avvicina.</h4>
<div class="outline-text-4" id="text-3-5-3">
<p>
Ruby ha delle fantastiche caratteristiche, questa è una di quelle.
Li abbiamo già visti, nei metodi <i>each</i> o <i>map</i> che abbiamo usato nei cicli. Possiamo scrivere metodi come quelli.
<i>Blocks</i>, <i>Procs</i>, <i>Closure</i> e <i>lambda</i>, sono sostanzialmente simili e scritti in maniera simile. Le differenze a volte sono solo <i>di fino</i> come si dice.
</p>

<p>
Vediamo come si scrive una <i>Proc</i>:
</p>

<div class="org-src-container">

<pre class="src src-ruby">ciao = <span class="org-type">Proc</span>.new <span class="org-keyword">do</span>
  <span class="org-builtin">puts</span> <span class="org-string">"ciao"</span>
<span class="org-keyword">end</span> 

ciao.call
ciao.call
ciao.call
</pre>
</div>

<p>
Questo scriverà tre volte <i>ciao</i>.
</p>

<div class="org-src-container">

<pre class="src src-sh">ciao
ciao
ciao
</pre>
</div>

<p>
Una Proc può prendere parametri:
</p>

<div class="org-src-container">

<pre class="src src-ruby">ciao = <span class="org-type">Proc</span>.new <span class="org-keyword">do</span> |a_chi|
  <span class="org-builtin">puts</span> <span class="org-string">"ciao"</span>
<span class="org-keyword">end</span> 

ciao.call(<span class="org-string">'Mondo'</span>)
ciao.call(<span class="org-string">'Carlo'</span>)
ciao.call(<span class="org-string">'Camilla'</span>)
</pre>
</div>

<p>
Il suo <i>output</i> sarà:
</p>

<div class="org-src-container">

<pre class="src src-sh">ciao Mondo
ciao Carlo
ciao Camilla
</pre>
</div>

<p>
La cosa fantastica delle <i>Proc</i> è che possiamo passarle come valori dei parametri e restituirle come valori dai metodi. Questo è un concetto complesso che a prima vista sembra non portare benefici ma non è così. È una caratteristi importante che fa di Ruby anche un <i>linguaggio funzionale</i> oltre che <i>orientato agli oggetti</i>, pur con alcune limitazioni.
</p>

<p>
Questo frammento definisce un metodo che prende come parametro una <i>Proc</i>:
</p>

<div class="org-src-container">

<pre class="src src-ruby">ciao = <span class="org-type">Proc</span>.new <span class="org-keyword">do</span>
  <span class="org-string">"ciao!"</span>
<span class="org-keyword">end</span>

buongiorno = <span class="org-type">Proc</span>.new <span class="org-keyword">do</span>
  <span class="org-string">"buongiorno!"</span>
<span class="org-keyword">end</span>

<span class="org-keyword">def</span> <span class="org-function-name">saluta_con_un</span>(proc)
  <span class="org-builtin">puts</span> <span class="org-string">"Ti saluto con un </span><span class="org-variable-name">#{proc.call}</span><span class="org-string">"</span>
<span class="org-keyword">end</span>

saluta_con_un(ciao)
saluta_con_un(buongiorno)
</pre>
</div>

<p>
In questo esempio ho usato un nuovo modo per concatenare le stringhe detto <i>interpolazione</i>. Funziona con le stringhe tra doppi apici (quelle in apici singoli non vanno bene) e praticamente il codice compreso tra <i>#{&#x2026;}</i> viene valutato ed il risultato sostituito in quel punto. Ci permette di costruire stringhe con elementi da valutare lì per lì.
</p>

<p>
Il suo <i>output</i> sarà:
</p>

<div class="org-src-container">

<pre class="src src-sh">Ti saluto con un ciao!
Ti saluto con un buongiorno!
</pre>
</div>

<p>
La <i>Proc</i> è stata passata come parametro ed invocata, questo perché la <i>Proc</i> è un valore, è un oggetto a tutti gli effetti. Un oggetto che contiene del codice.
</p>

<div class="org-src-container">

<pre class="src src-ruby">ciao = <span class="org-builtin">lambda</span> <span class="org-keyword">do</span>
  <span class="org-string">"ciao!"</span>
<span class="org-keyword">end</span>

buongiorno = <span class="org-type">Proc</span>.new <span class="org-keyword">do</span>
  <span class="org-string">"buongiorno!"</span>
<span class="org-keyword">end</span>

<span class="org-keyword">def</span> <span class="org-function-name">saluta_con_un</span>(proc)
  <span class="org-builtin">puts</span> <span class="org-string">"Ti saluto con un </span><span class="org-variable-name">#{proc.call}</span><span class="org-string">"</span>
<span class="org-keyword">end</span>

saluta_con_un(ciao)
saluta_con_un(buongiorno)
</pre>
</div>

<p>
Qui ho usato una <i>lambda</i>, <i>Proc</i> e <i>lambda</i> sono molto simili, la sintassi è praticamente identica. Ci sono differenze molto sottili di funzionamento che però vanno oltre lo scopo di questo minicorso.
</p>

<p>
Per finire un esempio di un metodo che prende come parametro un <i>Block</i>:
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-keyword">def</span> <span class="org-function-name">saluta</span>(persone, &amp;saluto)
  persone.each { |nome|
    salut = <span class="org-keyword">yield</span> saluto
    <span class="org-builtin">puts</span> <span class="org-string">"</span><span class="org-variable-name">#{ nome }</span><span class="org-string"> </span><span class="org-variable-name">#{ salut }</span><span class="org-string">"</span>
  }
<span class="org-keyword">end</span>

saluta([<span class="org-string">'Marco'</span>, <span class="org-string">'Giovanni'</span>, <span class="org-string">'Benedetta'</span>]) {
  <span class="org-string">"ciao"</span>
}
</pre>
</div>

<p>
Scriverà:
</p>

<div class="org-src-container">

<pre class="src src-sh">Marco ciao
Giovanni ciao
Benedetta ciao
</pre>
</div>

<p>
Queste possibilità di Ruby sono solo state scalfite. Sono molto potenti.
</p>
</div>
</div>

<div id="outline-container-sec-3-5-4" class="outline-4">
<h4 id="sec-3-5-4"><span class="section-number-4">3.5.4</span> Il mondo esterno</h4>
<div class="outline-text-4" id="text-3-5-4">
<p>
Fino ad adesso non abbiamo fatto altro che stare comodamente in casa, ma ogni tanto bisognerà uscire e parlare con la gente di fuori e magari non dimenticarsi quello che si è fatto.
Uno dei vari modi per uscire all'aperto è leggere e scrivere <i>file</i>. 
</p>

<p>
Lo avete fatto anche voi con il vostro <i>editor</i>, avete creato dei <i>file</i> sul disco del vostro computer e li avete letti, eseguiti con Ruby.
</p>

<p>
Ruby, come molti linguaggi ha la possibilità di <i>aprire</i> file, <i>scrivere o leggere</i> nei o dai file, <i>chiudere</i> i file. Non è un caso che abbia scritto: <i>aprire</i>, <i>leggere o scrivere</i>, <i>chiudere</i>; sono queste le fasi che servono per gestire i <i>file</i>.
</p>

<p>
Per fare questo abbiamo una <i>classe</i> che, ovviamente, si chiama <i>File</i>. <i>File</i> non fa solo quello, ha anche altri metodi che servono per esempio per avere informazioni sui <i>file</i> ma anche per gestirne i <i>percorsi</i>.
</p>

<p>
Un <i>percorso</i> serve per ritrovare un file nel disco del computer. Ci sono diverse <i>nomenclature</i> in base al sistema operativo che si sta usando e questo potrebbe rendere un po' complicato il gestirle.
</p>

<p>
Un <i>percorso</i> è formato da una serie di nomi di <i>cartelle</i> divisi da un separatore (qui è la differenza dei vari sistemi operativi) ed un nome di <i>file</i>.
</p>

<div class="org-src-container">

<pre class="src src-sh">/home/nissl/Documenti/Ruby/il_mio_file.txt
</pre>
</div>
<p>
Questo percorso è di tipo <i>Unix</i>.
</p>

<div class="org-src-container">

<pre class="src src-sh">c:\Documenti\Ruby\il_mio_file.txt
</pre>
</div>

<p>
Questo si usa con Microsoft Windows<sup>tm</sup>.
</p>

<p>
Senza entrare nelle differenze complicate, ne vediamo subito una e cioè la differenza di <i>separatore</i> (<i>slash</i> e <i>backslash</i>).
Fortunatamente Ruby, che è nato sui sistemi di tipo <i>Unix</i>, considera la forma con la barra normale (<i>slash</i>) <b>/</b> la forma corretta e quindi ragiona in questo modo facendolo fa anche su Windows<sup>tm</sup>. <br >
</p>

<p>
Quindi:
</p>

<div class="org-src-container">

<pre class="src src-sh">c:/Documenti/Ruby/il_mio_file.txt
</pre>
</div>

<p>
Per Ruby questo è corretto e lui troverà il file. Per il sistema operativo no però e questo potrebbe avere delle conseguenze in certi casi.
</p>

<p>
Vediamo come si apre un <i>file</i>:
</p>

<div class="org-src-container">

<pre class="src src-ruby">file = <span class="org-type">File</span>.open(<span class="org-string">'miofile.txt'</span>, <span class="org-string">'r'</span>)
</pre>
</div>

<p>
In questo modo, ho aperto un file in <i>sola lettura</i>, vuol dire che potrò leggerne il contenuto ma non lo potrò scrivere.
</p>

<p>
Ci sono vari <i>parametri di permesso</i> per i file e come si può vedere si indicano nel secondo valore dato al metodo mentre il primo è il nome del file.
</p>

<ul class="org-ul">
<li><b>r</b>: il file è aperto in <i>sola lettura</i> dal suo inizio.
</li>
<li><b>r+</b>: il file è aperto in <i>lettura e scrittura</i> dal suo inizio.
</li>
<li><b>w</b>: il file è aperto in <i>sola scrittura</i> e tronca il file a zero, cioè elimina il contenuto del file o ne crea uno se questo non esiste.
</li>
<li><b>w+</b>: il file è aperto in <i>lettura e scrittura</i> e tronca il file a zero, cioè elimina il contenuto del file o ne crea uno se questo non esiste.
</li>
<li><b>a</b>: il file è aperto in <i>sola scrittura</i> e aggiunge alla fine del file, <i>appende</i>.
</li>
<li><b>a+</b>: Il file è aperto in <i>lettura e scrittura</i> e aggiunge alla fine del file, <i>appende</i>.
</li>
</ul>

<p>
Queste sono le possibilità e l'uso dipende da quello che vogliamo fare con il file. Per esempio, se vogliamo solo leggere un file dobbiamo aprirlo in <i>sola lettura</i> per non rischiare di scriverci qualcosa inavvertitamente.
</p>

<p>
Esistono altre impostazioni da passare al metodo <i>open</i> o <i>new</i> oltre a queste, ma si rimanda alla documentazione ufficiale.
</p>

<p>
Ricordate sempre: <b>i <i>file</i> sono preziosi</b> e vanno gestiti in maniera adeguata.
</p>

<p>
Come ho accennato i file devono essere: aperti, letti o scritti, chiusi.
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-comment-delimiter">#</span><span class="org-comment">apro il file</span>
file = <span class="org-type">File</span>.open(<span class="org-string">'miofile.txt'</span>, <span class="org-string">'r'</span>)

<span class="org-comment-delimiter">#</span><span class="org-comment">leggo tutto il contenuto e lo metto nella variabile contenuto.</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">contenuto avr&#224; dentro tutto il testo come stringa (se il file &#232; di testo)</span>
contenuto = file.read

<span class="org-comment-delimiter">#</span><span class="org-comment">ho finito di leggerlo e lo chiudo: mai lasciare aperti i file.</span>
file.close
</pre>
</div>

<p>
Qui sopra ci sono le fasi. Una cosa molto importante è: <b>chiudere i file il prima possibile dopo averci lavorato</b>. <br >
</p>

<p>
Chiudere i file è importante per vari motivi, due di questi:
</p>

<ul class="org-ul">
<li>è pericoloso tenere aperto un file, si potrebbe distruggere o alterare
</li>
<li>i <i>file</i> sono una risorsa onerosa per il sistema operativo.
</li>
</ul>

<p>
Il sistema operativo, può tenere aperti solo un certo numero di file alla volta e per tutto il sistema. Questo è un limite che può essere impostato, ma sappiate che comunque ha un impatto sulla <i>velocità</i> con cui viene poi gestito il computer: l'hardware del computer. Ogni volta che aprite un file, si occuperà una parte di memoria da un oggetto del sistema operativo chiamato <i>descrittore</i>. Questo succede perché il vostro programma non gestisce direttamente il file, ma parla col sistema operativo.
Quando aprite un file chiedete al sistema operativo di aprirvelo e quando ci scrivete o leggete chiedete al sistema di leggerlo o scriverlo, poi dite al sistema di chiuderlo. <br >
</p>

<p>
Lui vi risponderà: - Era ora! -. <br >
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-comment-delimiter">#</span><span class="org-comment">apro il file</span>
file = <span class="org-type">File</span>.open(<span class="org-string">'miofile.txt'</span>, <span class="org-string">'r'</span>)

<span class="org-comment-delimiter">#</span><span class="org-comment">leggo tutto il contenuto e lo metto nella variabile contenuto.</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">contenuto sar&#224; un Array di stringhe, un elemento per riga (se il file &#232; di testo)</span>
contenuto = file.readlines

<span class="org-comment-delimiter">#</span><span class="org-comment">ho finito di leggerlo e lo chiudo: mai lasciare aperti i file.</span>
file.close
</pre>
</div>

<p>
Adesso ho letto il contenuto con il metodo <i>readlines</i> che mi restituisce un <i>Array di String</i>. Come vedete ci sono vari modi di leggere il contenuto di un file.
</p>

<p>
Questi sono modi adatti per file di piccole dimensioni, altrimenti si dovranno adottare diverse strategie sempre per non caricare troppo il sistema operativo.
</p>

<p>
I file, per esempio, si potrebbero leggere a <i>pezzi</i> più o meno grandi&#x2026;
</p>

<p>
Il nostro file lo abbiamo <i>letto</i>, ma per scriverlo?
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-comment-delimiter">#</span><span class="org-comment">apro il file</span>
file = <span class="org-type">File</span>.open(<span class="org-string">'miofile.txt'</span>, <span class="org-string">'w'</span>)

<span class="org-comment-delimiter">#</span><span class="org-comment">scrivo dentro il file (se il file &#232; di testo)</span>
file.write(<span class="org-string">'Ciao Mondo'</span>)

<span class="org-comment-delimiter">#</span><span class="org-comment">ho finito di scrivere e lo chiudo: mai lasciare aperti i file.</span>
file.close
</pre>
</div>

<p>
Ho scritto la stringa <i>Ciao Mondo</i> nel file. Adesso sul disco avremo un file dal nome <i>miofile.txt</i> con dentro la frase: <i>Ciao Mondo</i>.
</p>

<p>
Visto che aprire e chiudere i file è così importante, Ruby ci mette a disposizione una versione del metodo <i>open</i> molto interessante:
</p>

<div class="org-src-container">

<pre class="src src-ruby">contenuto = <span class="org-string">''</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">apro il file</span>
<span class="org-type">File</span>.open(<span class="org-string">'miofile.txt'</span>, <span class="org-string">'r'</span>) <span class="org-keyword">do</span> |file|

<span class="org-comment-delimiter">#</span><span class="org-comment">leggo tutto il contenuto e lo metto nella variabile contenuto.</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">contenuto avr&#224; dentro tutto il testo come stringa (se il file &#232; di testo)</span>
contenuto = file.read

<span class="org-keyword">end</span>
</pre>
</div>

<p>
Come si può vedere, al metodo è associata una <i>closure</i>. Questa versione sostanzialmente si prende cura di chiudere il file all' uscita del blocco della <i>closure</i>. 
</p>

<p>
<i>Insomma se scriviamo così non ci dobbiamo preoccupare di chiudere il file perché sarà automatico. Non è un vantaggio?</i>
</p>

<p>
La classe <i>File</i>, come vi ho già detto, ha molti metodi per la gestione dei file. Alcuni interessanti sono questi:
</p>

<ul class="org-ul">
<li><b>File.exist?('miofile.txt')</b>: controlla se il file esiste.
</li>
<li><b>File.file?('miofile.txt')</b>: controlla se un file è un file.
</li>
<li><b>File.directory?('miadirectory')</b>: controlla se un file è una cartella (directory).
</li>
<li><b>File.ftype('miofile.txt')</b>: controlla che tipo di file è, per esempio se è un file o una directory.
</li>
<li><b>File.size('miofile.txt')</b>: controlla quando è grande, quanto spazio occupa sul disco.
</li>
<li><b>File.join('cartella1', 'cartella2', 'miofile.txt')</b>: costruisce un percorso di file concatenando due o più stringhe.
</li>
<li><b>File.basename('/cartella1/cartella2/miofile.txt')</b>: ritornerà solo il nome del file <i>miofile.txt</i>.
</li>
<li><b>File.diname('/cartella1/cartella2/miofile.txt')</b>: ritornerà solo il percorso delle directory senza il nome del file.
</li>
<li><b>File.extname('miofile.txt')</b>: ritornerà l'estensione del nome del file, cioè il testo dopo il punto ma col punto compreso (<i>.txt</i>).
</li>
</ul>

<p>
Ce ne sono altri di metodi e ci sono, inoltre, anche altre classi per la gestione dei file. I file non si creano, leggono o scrivono soltanto; ma si rinominano, spostano, cancellano e così via.
</p>

<p>
Quello che abbiamo visto qui serve per i <i>file di testo</i>, cioè quelli che contengono caratteri e che quando si leggono vi si accede come fossero delle stringhe. I file oltre che di <i>testo</i> possono essere anche <i>binari</i> e quindi codificati direttamente in <i>byte</i>. Vi si accede praticamente nello stesso modo, ma bisogna usare con i metodi che vi ho detto altri parametri. Non è particolarmente semplice, quindi per adesso va bene così.
</p>
</div>
</div>

<div id="outline-container-sec-3-5-5" class="outline-4">
<h4 id="sec-3-5-5"><span class="section-number-4">3.5.5</span> I dizionari</h4>
<div class="outline-text-4" id="text-3-5-5">
<p>
Conoscerete il dizionario, quel librone grosso con tante parole in fila&#x2026; I significati delle parole. Quello che va da <i>abaco</i> a <i>zuzzurellone</i> (per la verità, se controllate comincia con la <i>a</i>, però è così che corre voce).
</p>

<p>
Sappiate che Ruby ha i <i>dizionari</i>, la classe si chiama <i>Hash</i> (il motivo c'è ma è complicato). In altri linguaggi di programmazione si chiamano <i>Map</i> (mappa) ma il concetto è lo stesso.
</p>

<p>
Un dizionario o mappa o Hash è un tipo di dato estremamente utile.
</p>

<div class="org-src-container">

<pre class="src src-ruby">dizionario = { <span class="org-string">'nome'</span> =&gt; <span class="org-string">'massimo'</span>, <span class="org-string">'cognome'</span> =&gt; <span class="org-string">'ghisalberti'</span>}
</pre>
</div>

<p>
Questo è come si dichiara velocemente. La variabile <i>dizionario</i> contiene un <i>hash</i> con due <i>chiavi</i>: nome e cognome.
Se volessi accedere al valore indicato dalla chiave <i>nome</i>:
</p>

<div class="org-src-container">

<pre class="src src-ruby">il_mio_nome = dizionario[<span class="org-string">'nome'</span>]
</pre>
</div>

<p>
La variabile <i>il_mio_nome</i> a questo punto conterrà <i>massimo</i>.
</p>

<div class="org-src-container">

<pre class="src src-ruby">irb(main)<span class="org-constant">:001</span>:0&gt; dizionario = { <span class="org-string">'nome'</span> =&gt; <span class="org-string">'massimo'</span>, <span class="org-string">'cognome'</span> =&gt; <span class="org-string">'ghisalberti'</span>}
=&gt; {<span class="org-string">"nome"</span>=&gt;<span class="org-string">"massimo"</span>, <span class="org-string">"cognome"</span>=&gt;<span class="org-string">"ghisalberti"</span>}
irb(main)<span class="org-constant">:002</span>:0&gt; dizionario[<span class="org-string">'nome'</span>]
=&gt; <span class="org-string">"massimo"</span>
irb(main)<span class="org-constant">:003</span>:0&gt;
</pre>
</div>

<p>
Vi assicuro che degli <i>Hash</i> non potrete farne a meno, sono utilissimi.
In qualche maniera sono simili agli Array, nel senso che hanno metodi simili. Anche gli <i>Hash</i> sono collezioni:
</p>

<div class="org-src-container">

<pre class="src src-ruby">dizionario = { <span class="org-string">'nome'</span> =&gt; <span class="org-string">'massimo'</span>, <span class="org-string">'cognome'</span> =&gt; <span class="org-string">'ghisalberti'</span>}
dizionario.each <span class="org-keyword">do</span> |chiave,valore|
  <span class="org-builtin">puts</span> <span class="org-string">"chiave: "</span> + chiave
  <span class="org-builtin">puts</span> <span class="org-string">"valore: "</span> + valore
<span class="org-keyword">end</span>
</pre>
</div>

<p>
Salvate come <i>dizionario.rb</i> ed eseguite:
</p>

<div class="org-src-container">

<pre class="src src-sh">&#10140;  ruby dizionario.rb 
chiave: nome
valore: massimo
chiave: cognome
valore: ghisalberti
&#10140;
</pre>
</div>

<p>
come vedete, potete accedere in questo modo alle coppie <i>chiave -&gt; valore</i>.
I <i>dizionari</i> di Ruby sono estremamente flessibili, la chiave può essere di qualunque tipo supportato da Ruby e così i valori. Potete mischiare le cose&#x2026;
</p>

<div class="org-src-container">

<pre class="src src-ruby">dizionario = { 1 =&gt; <span class="org-string">'massimo'</span>, <span class="org-string">'cognome'</span> =&gt; <span class="org-string">'ghisalberti'</span>}
dizionario.each <span class="org-keyword">do</span> |chiave,valore|
  <span class="org-builtin">puts</span> chiave
  <span class="org-builtin">puts</span> valore
<span class="org-keyword">end</span>
</pre>
</div>

<p>
Eseguendolo, produrrà questo:
</p>

<div class="org-src-container">

<pre class="src src-sh">&#10140;  ruby dizionario.rb 
chiave: 1
valore: massimo
chiave: cognome
valore: ghisalberti
&#10140;
</pre>
</div>

<p>
Adesso una chiave è un <i>Fixnum</i>, un numero, mentre l'altra una stringa. <br >
</p>

<p>
Adesso mi direte: - Perché i parli adesso degli Hash se sono così utili? - <br >
</p>

<p>
La risposta è che, perché vi ho parlato di come si salva un file. Questa è la risposta corta.
Quella lunga invece è che un <i>hash</i> (ma anche un Array) può essere facilmente <i>serializzato</i>. Che vuol dire?
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-builtin">require</span> <span class="org-string">'yaml'</span>

rubrica = [

  {<span class="org-constant">:nome</span> =&gt; <span class="org-string">'Massimo'</span>, <span class="org-constant">:cognome</span> =&gt; <span class="org-string">'Ghisalberti'</span>, <span class="org-constant">:telefono</span> =&gt; <span class="org-string">'1234567890'</span>},
  {<span class="org-constant">:nome</span> =&gt; <span class="org-string">'Mario'</span>, <span class="org-constant">:cognome</span> =&gt; <span class="org-string">'Rossi'</span>, <span class="org-constant">:telefono</span> =&gt; <span class="org-string">'1234567890'</span>}

]

<span class="org-builtin">puts</span> <span class="org-string">"La rubrica come array"</span>
<span class="org-builtin">p</span> rubrica
puts

<span class="org-builtin">puts</span> <span class="org-string">"la rubrica serializzata come YAML"</span>
<span class="org-builtin">p</span> rubrica.to_yaml
puts

<span class="org-builtin">puts</span> <span class="org-string">"Salvo la rubrica su un file"</span>
puts
<span class="org-type">File</span>.open(<span class="org-string">'rubrica.yml'</span>, <span class="org-string">'w'</span>) <span class="org-keyword">do</span> |file|
  file.write(rubrica.to_yaml)
<span class="org-keyword">end</span>


<span class="org-builtin">puts</span> <span class="org-string">"Leggo la rubrica su un file"</span>
puts
dati = []
<span class="org-type">File</span>.open(<span class="org-string">'rubrica.yml'</span>, <span class="org-string">'r'</span>) <span class="org-keyword">do</span> |file|
  yaml = <span class="org-type">YAML</span>.load(file.read)
  dati = yaml.to_a
<span class="org-keyword">end</span>

<span class="org-builtin">puts</span> <span class="org-string">"La rubrica ricaricata dal file"</span>
<span class="org-builtin">p</span> dati
</pre>
</div>

<p>
Salvate come <i>dizionario2.rb</i> ed eseguite.
</p>

<div class="org-src-container">

<pre class="src src-sh">&#10140;  ruby dizionario2.rb
La rubrica come array
[{:<span class="org-variable-name">nome</span>=&gt;<span class="org-string">"Massimo"</span>, :<span class="org-variable-name">cognome</span>=&gt;<span class="org-string">"Ghisalberti"</span>, :<span class="org-variable-name">telefono</span>=&gt;<span class="org-string">"1234567890"</span>}, {:<span class="org-variable-name">nome</span>=&gt;<span class="org-string">"Mario"</span>, :<span class="org-variable-name">cognome</span>=&gt;<span class="org-string">"Rossi"</span>, :<span class="org-variable-name">telefono</span>=&gt;<span class="org-string">"1234567890"</span>}]

la rubrica serializzata come YAML
<span class="org-string">"---\n- :nome: Massimo\n  :cognome: Ghisalberti\n  :telefono: '1234567890'\n- :nome: Mario\n  :cognome: Rossi\n  :telefono: '1234567890'\n"</span>

Salvo la rubrica su un file

Leggo la rubrica su un file

La rubrica ricaricata dal file
[{:<span class="org-variable-name">nome</span>=&gt;<span class="org-string">"Massimo"</span>, :<span class="org-variable-name">cognome</span>=&gt;<span class="org-string">"Ghisalberti"</span>, :<span class="org-variable-name">telefono</span>=&gt;<span class="org-string">"1234567890"</span>}, {:<span class="org-variable-name">nome</span>=&gt;<span class="org-string">"Mario"</span>, :<span class="org-variable-name">cognome</span>=&gt;<span class="org-string">"Rossi"</span>, :<span class="org-variable-name">telefono</span>=&gt;<span class="org-string">"1234567890"</span>}]
&#10140;
</pre>
</div>

<p>
È un piccolo programma che salva un <i>array di hash</i> e cioè una <i>collezione di dizionari</i> su un file e la ricarica. Ho utilizzato un <i>formato di dati</i> molto comune nel mondo Ruby, lo YAML (<a href="http://yaml.org/">http://yaml.org/</a>).
È un formato di struttura dati abbastanza semplice e versatile e soprattutto <i>testuale</i>. Se aprite il file <i>rubrica.yml</i> vedrete che è così:
</p>

<div class="org-src-container">

<pre class="src src-yaml"><span class="org-comment">---</span>
- <span class="org-variable-name">:nome</span>: Massimo
  <span class="org-variable-name">:cognome</span>: Ghisalberti
  <span class="org-variable-name">:telefono</span>: <span class="org-string">'1234567890'</span>
- <span class="org-variable-name">:nome</span>: Mario
  <span class="org-variable-name">:cognome</span>: Rossi
  <span class="org-variable-name">:telefono</span>: <span class="org-string">'1234567890'</span>
</pre>
</div>

<p>
Se volete potete aggiungere direttamente qui:
</p>

<div class="org-src-container">

<pre class="src src-yaml"><span class="org-comment">---</span>
- <span class="org-variable-name">:nome</span>: Massimo
  <span class="org-variable-name">:cognome</span>: Ghisalberti
  <span class="org-variable-name">:telefono</span>: <span class="org-string">'1234567890'</span>
- <span class="org-variable-name">:nome</span>: Mario
  <span class="org-variable-name">:cognome</span>: Rossi
  <span class="org-variable-name">:telefono</span>: <span class="org-string">'1234567890'</span>
- <span class="org-variable-name">:nome</span>: Pico
  <span class="org-variable-name">:cognome</span>: De paperis
  <span class="org-variable-name">:telefono</span>: <span class="org-string">'0234567890'</span>
</pre>
</div>

<p>
Quando lo rileggerete nel modo indicato avrete un dizionario in più nel vostro array.
Utilizzando il metodo <i>to_yaml</i> ho convertito, in questo caso l'array ma anche tutti i tipi di dati in esso contenuti, in una struttura dati <i>Yaml</i> che ho salvato sul disco.
Dopo ho ricaricato i dati dal file aperto come struttura dati Yaml attraverso <i>YAML.load</i> e convertito di nuovo in dati Ruby con <i>to_a</i> (<i>to array</i>).
Sembra contorto ed un po' lo è, ma questa /"cosa"/ vi permette di avere facilmente il modo di poter salvare velocemente dati sul disco e di recuperarli in seguito.
</p>

<p>
Pensate anche che lo Yaml non lo gestisce solo Ruby, ma si può aprire e leggere da molti altri linguaggi di programmazione.
</p>

<p>
Per <i>amor di cronaca</i> esiste anche un altro sistema di strutture dati testuali che oggi va per la maggiore ed è il JSON (<a href="http://json.org/">http://json.org/</a>). Ruby ha un <i>serializzatore</i> e <i>deserializzatore</i> anche per il JSON.
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-builtin">require</span> <span class="org-string">'json'</span>

rubrica = [

  {<span class="org-constant">:nome</span> =&gt; <span class="org-string">'Massimo'</span>, <span class="org-constant">:cognome</span> =&gt; <span class="org-string">'Ghisalberti'</span>, <span class="org-constant">:telefono</span> =&gt; <span class="org-string">'1234567890'</span>},
  {<span class="org-constant">:nome</span> =&gt; <span class="org-string">'Mario'</span>, <span class="org-constant">:cognome</span> =&gt; <span class="org-string">'Rossi'</span>, <span class="org-constant">:telefono</span> =&gt; <span class="org-string">'1234567890'</span>}

]

<span class="org-builtin">puts</span> <span class="org-string">"La rubrica come array"</span>
<span class="org-builtin">p</span> rubrica
puts

<span class="org-builtin">puts</span> <span class="org-string">"la rubrica serializzata come YAML"</span>
<span class="org-builtin">p</span> rubrica.to_json
puts

<span class="org-builtin">puts</span> <span class="org-string">"Salvo la rubrica su un file"</span>
puts
<span class="org-type">File</span>.open(<span class="org-string">'database.json'</span>, <span class="org-string">'w'</span>) <span class="org-keyword">do</span> |file|
  file.write(rubrica.to_json)
<span class="org-keyword">end</span>


<span class="org-builtin">puts</span> <span class="org-string">"Leggo la rubrica su un file"</span>
puts
dati = []
<span class="org-type">File</span>.open(<span class="org-string">'database.json'</span>, <span class="org-string">'r'</span>) <span class="org-keyword">do</span> |file|
  json = <span class="org-type">JSON</span>.load(file.read)
  dati = json.to_a
<span class="org-keyword">end</span>

<span class="org-builtin">puts</span> <span class="org-string">"La rubrica ricaricata dal file"</span>
<span class="org-builtin">p</span> dati
</pre>
</div>

<p>
Come vedete i metodi sono molto simili.
</p>

<p>
Sia per il <i>JSON</i> che lo <i>Yaml</i> dovete, prima di usarli, richiederli con la <i>require</i>.
</p>

<p>
Come ultima cosa sugli <i>Hash</i> voglio farvi notare una cosa: ho usato per le chiavi il tipo <i>Symbol</i>. Il simbolo è un tipo particolare simile ad una stringa, ma non è <i>mutabile</i>, non si possono cioè manipolare i caratteri che lo compongono. Ha una sua importanza in molti casi, ma soprattutto come chiavi dentro i dizionari dove si suppone che la chiave non cambi mai, ma cambi solo il valore. Ruby fa della <i>magia sua interna</i> con i simboli ma spiegarla va oltre lo scopo di questo piccolo corso.
</p>
</div>
</div>

<div id="outline-container-sec-3-5-6" class="outline-4">
<h4 id="sec-3-5-6"><span class="section-number-4">3.5.6</span> Le finestre che si aprono o si chiudono se fa freddo.</h4>
<div class="outline-text-4" id="text-3-5-6">
<p>
Apriamo le finestre, oggi si arieggia.
</p>
</div>

<div id="outline-container-sec-3-5-6-1" class="outline-5">
<h5 id="sec-3-5-6-1"><span class="section-number-5">3.5.6.1</span> Divagazioni sul tema</h5>
<div class="outline-text-5" id="text-3-5-6-1">
<p>
Una delle parti più complicate e noiose del <i>programmare</i> sono le interfacce grafiche.
Tutti voi avete dei sistemi operativi grafici, più o meno basati sul <i>paradigma della finestra</i> o sul <i>padadigma della vista</i>.
</p>

<p>
Sappiate che contrariamente a quello che sapete o avete sentito più spesso dire, <i>Apple</i> o <i>Microsoft</i> in questo non si sono inventati niente. Insomma <i>Jobs</i> e <i>Gates</i> hanno solo rubacchiato qua e là.
</p>

<p>
Orrore! Qualcuno si sentirà male, qualcuno mi vorrà picchiare per aver <i>insultato</i> i suoi idoli (specialmente quelli a cui piacciono le mele).
</p>

<p>
Ragazzi, tenetevi forte&#x2026; <br >
</p>

<p>
Tutto quello che conoscete è stato inventato dalla <i>Xerox</i> in certi laboratori, il <i>PARC</i>, che aveva negli anni '70. 
A <i>Palo Alto</i> in California, i ricercatori geniali della <i>Xerox</i> hanno inventato l'informatica moderna.
</p>

<ul class="org-ul">
<li>Il <i>mouse</i> (questo lo conoscete tutti)
</li>
<li>la stampa laser (anche questa dovrebbe essere chiara)
</li>
<li>l'<i>ethernet</i> (ogni computer oggi ha una scheda ethernet per collegarsi a Internet)
</li>
<li>la <i>grafica bitmap</i> (le fotografie le fate?)
</li>
<li>le <i>interfacce grafiche</i> (Le finestre di Microsoft Windows<sup>tm</sup> o di Apple MacOSX<sup>tm</sup>?)
</li>
<li>gli editor <i>WYSIWYG</i>, What You See Is What You Get (i word processor, avete presente Microsoft Word<sup>tm</sup>?)
</li>
<li><i>Interpress</i> (poi evoluto da Adobe nel postscript e finito nel PDF)
</li>
<li>la programmazione orientata agli oggetti (con Smalltalk)
</li>
<li>l'architettura <i>MVC</i>, <i>Model View Controller</i> (che oggi è usatissima)
</li>
<li>gli <i>LCD</i> (gli schermi a cristalli liquidi)
</li>
<li>i dischi ottici di memorizzazione (Philips poi fece il CD su queste ricerche nell'80)
</li>
<li>ubiquitous computing (il calcolo distribuito)
</li>
<li>la programmazione ad aspetti (Aspect Oriented Programming)
</li>
<li>IPv6 (il nuovo protocollo per la comunicazione tra computer che ancora non abbiamo, Internet per adesso è ancora basato sull IPv5)
</li>
</ul>

<p>
Tutto questo è stato <i>studiato</i> e, o, <i>inventato</i> tra la fine degli anni '60 ed i primi anni '80.
</p>

<p>
<i>Alan Key</i>, uno di questi pionieri ed inventore Smalltalk (implementato da <i>Dan Ingalls</i>), propose nel 1972 il <i>Dynabook</i>.
<i>Dynabook</i> sarebbe dovuto essere un computer portatile a batteria (simile ad un tablet odierno, quindi Apple non ha inventato il tablet), con una batteria virtualmente eterna, collegato in rete wireless, con un sistema operativo grafico.
</p>

<p>
Durante questa ricerca, <i>Key</i>, inventò <i>Smalltalk</i> ed i sistemi operativi grafici. Stimò allora (1972) per la costruzione del <i>Dynabook</i> un costo di 6000 dollari. 
</p>

<p>
<i>Alan Key</i> è fortemente impegnato nell'insegnamento della programmazione ai bambini e nella divulgazione dell'informatica a tutti i livelli, per esempio nel progetto: <i>One Laptop Per Child</i> (<a href="http://en.wikipedia.org/wiki/One_Laptop_per_Child">http://en.wikipedia.org/wiki/One_Laptop_per_Child</a>) che si prefiggeva la costruzione e distribuzione a basso costo di computer adatti all'insegnamento e per zone disagiate (XO-1 è uscito intorno al 2008).
</p>
</div>
</div>

<div id="outline-container-sec-3-5-6-2" class="outline-5">
<h5 id="sec-3-5-6-2"><span class="section-number-5">3.5.6.2</span> Facciamole queste finestre, che ci siamo annoiati!</h5>
<div class="outline-text-5" id="text-3-5-6-2">
<p>
Dopo questa divagazione sul tema lunga e noiosa veniamo al dunque.
</p>

<p>
Programmare l'interfaccia grafica di un programma è un lavoro lungo e spesso noioso, non è difficile ma ripetitivo e dispersivo. Se prima lanciare a <i>linea di comando</i> vi era sembrato <i>brutto</i> e <i>noioso</i> dopo questo lo amerete! <br >
</p>
</div>

<div id="outline-container-sec-3-5-6-2-1" class="outline-6">
<h6 id="sec-3-5-6-2-1"><span class="section-number-6">3.5.6.2.1</span> il problema</h6>
<div class="outline-text-6" id="text-3-5-6-2-1">
<p>
Esistono molte librerie per la <i>definizione</i> delle interfacce grafiche, il sistema operativo grafico ne ha una sua che è spesso abbastanza complicata. Microsoft Windows<sup>tm</sup> ha la sua, il MacOSX la sua, i vari <i>desktop</i> Linux (KDE, Gnome per citarne solo due) la loro, Android la sua, IOS la sua. È un vero caos (ricordate che <i>casino</i> è una parolaccia e non si può dire).
</p>

<p>
Pensate poi al problema di un programma fatto per funzionare su tutti questi sistemi.
Non è più un <i>caos</i>, è un vero <i>incubo</i>&#x2026; Altro che i mostri sotto il letto o dentro l'armadio.
</p>

<p>
Per cercare di facilitarsi la vita, molti programmatori hanno scritto delle librerie che però hanno le loro regole.
Insomma <i>caos</i> aggiunto al <i>caos</i>.
</p>

<p>
La scelta di una buona libreria è importante per la durata e la <i>mantenibilità</i> (un software va mantenuto, curato e ci vanno aggiunte funzionalità o tolte) di un programma per computer.
</p>

<p>
Ci sono linguaggi di programmazione migliori di altri in questo, alcuni sono stati appositamente progettati per la definizione delle interfacce e quindi alcune cose sono facilitate.
</p>

<p>
Sfortunatamente Ruby non è uno di questi, ma ha una cosa molto importante: è <i>Ruby</i>. Poi, forse, questa affermazione sarà più chiara.
</p>

<p>
Per descrivere una interfaccia grafica abbiamo bisogno di usare una libreria apposta.
</p>
</div>
</div>


<div id="outline-container-sec-3-5-6-2-2" class="outline-6">
<h6 id="sec-3-5-6-2-2"><span class="section-number-6">3.5.6.2.2</span> Le scarpette rosse</h6>
<div class="outline-text-6" id="text-3-5-6-2-2">
<p>
In questo mini corso vedremo come usare <i>Shoes</i> (<a href="http://shoesrb.com/">http://shoesrb.com/</a>). <br >
</p>

<p>
Dovete scaricare una distribuzione di <i>Shoes</i> per il vostro sistema <a href="http://shoesrb.com/downloads/">http://shoesrb.com/downloads/</a>). Una volta installata avrete un eseguibile che si chiama <i>shoes</i> con cui potete lanciare i vostri programmi. 
Se volte potete lanciare anche i vecchi programmi che avete fatto fino ad adesso, <i>Shoes</i> è una libreria per Ruby che fornisce un comando per convenienza. Ruby c'è ancora e funziona.
</p>

<div class="org-src-container">

<pre class="src src-sh">shoes tabellina.rb
</pre>
</div>

<p>
L'unica cosa è che il programma non termina da solo ma dovete fermarlo con la combinazione di tasti: <i>CRTL+c</i> (CTRL è il tasto Control, cercatelo sulla tastiera e premete prima quello e tenendolo premuto battete il tasto c, poi lasciateli tutti e due). <br >
</p>

<p>
Vi ho fatto scaricare una distribuzione di Shoes completa perché non è facile da installare dentro Ruby specialmente se usate Microsoft Windows<sup>tm</sup>. <br >
</p>

<p>
Cominciamo con una cosa semplicissima:
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-type">Shoes</span>.app { 
  button <span class="org-string">"Ciao, premi..."</span> 
}
</pre>
</div>

<p>
Salvatelo come <i>scarpe.rb</i> ed eseguitelo con: <i>shoes scarpe.rb</i>.
</p>

<p>
Alleluja! Il vostro primo programma grafico! Con Anche un bottone!
</p>

<p>
La finestra la potete spostare, ingrandire, rimpicciolire&#x2026; Insomma ha un po' tutto.
Tutto quello che è dentro <i>Shoes.app</i> è la nostra applicazione <i>Shoes</i>.
</p>

<p>
Aggiungiamo un altro bottone?
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-type">Shoes</span>.app { 
  button <span class="org-string">"Ciao, premi..."</span>
  button <span class="org-string">"Io sono il secondo bottone, premi..."</span> 
}
</pre>
</div>

<p>
Salvatelo come <i>scarpe2.rb</i> ed eseguitelo con: <i>shoes scarpe2.rb</i>.
</p>

<p>
Vogliamo disegnare un cerchio? Via!
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-type">Shoes</span>.app { 
  button <span class="org-string">"Ciao, premi..."</span>
  button <span class="org-string">"Io sono il secondo bottone, premi..."</span> 

  oval(<span class="org-constant">left</span>: 20, <span class="org-constant">top</span>: 40, <span class="org-constant">radius</span>: 50)

}
</pre>
</div>

<p>
Salvatelo come <i>scarpe3.rb</i> ed eseguitelo con: <i>shoes scarpe3.rb</i>.
</p>

<p>
Lo vogliamo rosso?
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-type">Shoes</span>.app { 
  button <span class="org-string">"Ciao, premi..."</span>
  button <span class="org-string">"Io sono il secondo bottone, premi..."</span> 

  fill(red)
  oval(<span class="org-constant">left</span>: 20, <span class="org-constant">top</span>: 40, <span class="org-constant">radius</span>: 50)

  fill(green)
  rect(<span class="org-constant">left</span>: 20, <span class="org-constant">top</span>: 100, <span class="org-constant">width</span>: 50)

}
</pre>
</div>

<p>
Salvatelo come <i>scarpe4.rb</i> ed eseguitelo con: <i>shoes scarpe4.rb</i>.
</p>

<p>
Ho fatto anche un quadrato verde. Shoes ha numerosi oggetti grafici già disegnati: 
</p>

<ul class="org-ul">
<li><b>oval</b> per disegnare ovali, quindi anche cerchi
</li>
<li><b>rect</b> per i rettangoli e quadrati
</li>
<li><b>star</b> per fare delle stelle
</li>
<li><b>image</b> per caricare immagini, anche via internet
</li>
<li><b>arrow</b> per fare delle frecce
</li>
<li><b>video</b> per guardare dei video
</li>
<li><b>&#x2026;</b>
</li>
</ul>

<p>
Oltre questi metodi per avere cose già fatte, possiamo sempre disegnarle noi con <i>stroke</i> (tratto) e <i>fill</i> (riempi).
Insomma, con penna e colore potete disegnare.
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-type">Shoes</span>.app <span class="org-keyword">do</span>
  <span class="org-variable-name">@stella</span> = star(<span class="org-constant">points</span>: 5)
  motion <span class="org-keyword">do</span> |sinistra, alto|
    <span class="org-variable-name">@stella</span>.move sinistra, alto
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>
</div>

<p>
Salvatelo come <i>scarpe5.rb</i> ed eseguitelo con: <i>shoes scarpe5.rb</i>.
Muovete il mouse. la stella vi viene dietro.
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-type">Shoes</span>.app <span class="org-keyword">do</span>
  fill(yellow)
  <span class="org-variable-name">@cerchio</span> = oval(<span class="org-constant">left</span>: 40, <span class="org-constant">top</span>: 40, <span class="org-constant">radius</span>: 40)
  animate <span class="org-keyword">do</span> |i|
    <span class="org-variable-name">@cerchio</span>.top += (-20..20).rand
    <span class="org-variable-name">@cerchio</span>.left += (-20..20).rand
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>
</div>

<p>
Salvatelo come <i>scarpe6.rb</i> ed eseguitelo con: <i>shoes scarpe6.rb</i>.
Abbiamo animato con il metodo <i>animate</i> ed avremo un cerchio giallo che ballonzola in giro in maniera casuale.
</p>

<p>
La forma: <i>(-20..20)</i> è un <i>Range</i>, serve per esprimere un intervallo di numeri. Il metodo <i>rand</i> ne prende uno a caso dentro questo <i>Range</i>.
</p>

<p>
L'espressione:
</p>

<div class="org-src-container">

<pre class="src src-ruby">variabile = 1

<span class="org-comment-delimiter">#</span><span class="org-comment">questa forma &#232; equivalente a quella dopo</span>
variabile += 1

<span class="org-comment-delimiter">#</span><span class="org-comment">questa forma &#232; equivalente a quella prima</span>
variabile = variabile + 1
</pre>
</div>

<p>
utilizza un <i>operatore</i> che chiameremo di <i>incremento</i> <i>+=</i>. Ruby ha una serie di <i>operatori misti</i> come questo, per esempio utile è:
</p>

<div class="org-src-container">

<pre class="src src-ruby">variabile ||= 1
</pre>
</div>

<p>
che assegnerà il valore 1 alla variabile solo se non contiene già un valore. Utile per inizializzare le variabili.
</p>

<p>
Ritorniamo al nostro bottone di prima:
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-type">Shoes</span>.app { 
  button(<span class="org-string">"premi..."</span>) {
    alert(<span class="org-string">"Ciao Mondo!"</span>)
  }
}
</pre>
</div>

<p>
Salvatelo come <i>scarpe7.rb</i> ed eseguitelo con: <i>shoes scarpe7.rb</i>.
</p>

<p>
Premete il bottone&#x2026; Avete aperto una <i>finestra di dialogo</i>, una di quelle che se non le chiudete non potete fare più niente (in gergo difficile si dice <i>finestra modale</i>).
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-type">Shoes</span>.app { 
  button(<span class="org-string">"premi..."</span>) {
    alert(<span class="org-string">"Ciao Mondo1!"</span>)
  }
  button(<span class="org-string">"premi..."</span>) {
    alert(<span class="org-string">"Ciao Mondo2!"</span>)
  }
}
</pre>
</div>

<p>
Salvatelo come <i>scarpe8.rb</i> ed eseguitelo con: <i>shoes scarpe8.rb</i>.
</p>

<p>
<i>Siore e Siori</i> abbiamo due bottoni che funzionano!
</p>

<p>
Vediamo un campo di input, salvate come <i>scarpe8.rb</i> e lanciate:
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-type">Shoes</span>.app <span class="org-keyword">do</span>

  background <span class="org-string">"#00ffff"</span>
  border(<span class="org-string">"#ff0000"</span>, <span class="org-constant">strokewidth</span>: 6)

  stack(<span class="org-constant">margin</span>: 12) <span class="org-keyword">do</span>
    title(<span class="org-string">"Giochino"</span>)
    para(<span class="org-string">"Inserisci il tuo nome:"</span>)
    flow <span class="org-keyword">do</span>
      <span class="org-variable-name">@input_field</span> = edit_line
      button(<span class="org-string">"OK"</span>) <span class="org-keyword">do</span>
         alert(<span class="org-string">"Ciao "</span> + <span class="org-variable-name">@input_field</span>.text)
      <span class="org-keyword">end</span>
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>
</div>

<p>
Se lo eseguite, scrivete il vostro nome e premete il bottone; una finestra modale vi dirà: - Ciao &#x2026; -.
</p>

<p>
Qui possiamo notare diversi elementi.
il metodo <i>stack</i> che <i>impila</i> gli elementi che contiene, a cui possiamo fornire un margine e cioè di quanto è rientrato rispetto all'elemento che lo contiene (in questo caso la finestra principale). Il metodo <i>flow</i> invece permette di allineare, <i>far fluire</i>, i due elementi <i>edit_line</i> e <i>button</i> mantenendoli uno accanto all'altro.
Il contenuto del <i>campo di input</i> che ho chiamato <i>edit_field</i> è recuperato con il metodo <i>text</i> del campo di input.
Il metodo <i>para</i> sta per paragrafo (<i>paragraph</i>) e serve per scrivere una linea di testo, mentre <i>title</i> mette del testo in un carattere più grande.
</p>

<p>
Per <i>colorare la finestra</i> abbiamo usato <i>background</i> e <i>border</i>, il primo riempe di colore lo sfondo e il secondo costruisce un bordo intorno (la proprietà <i>strokewidth</i> (<i>larghezza del tratto</i>) è lo spessore del bordo.
</p>

<p>
Ci sono altri metodi per i testi che possono essere usati insieme, salvate come <i>scarpe10.rb</i>:
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-type">Shoes</span>.app {
  stack(<span class="org-constant">margin</span>: 6) {
    title(<span class="org-string">"Formattazione del testo"</span>)
    para(strong(<span class="org-string">"Domanda"</span>), <span class="org-string">" Quanto sei alto?"</span>)
    para(em(strong(<span class="org-string">"Risposta"</span>), <span class="org-string">" Sono alto un metro e mezzo."</span>))
  }
}
</pre>
</div>

<p>
<i>strong</i> metterà il testo in <i>grassetto</i> mentre <i>em</i> lo metterà in corsivo. 
</p>


<div class="org-src-container">

<pre class="src src-ruby"><span class="org-type">Shoes</span>.app(<span class="org-constant">title</span>: <span class="org-string">"Il bottone"</span>) {

  stack {
    <span class="org-variable-name">@bottone</span> = button( <span class="org-string">"Premi"</span>) 
    <span class="org-variable-name">@note</span> = para(em(<span class="org-string">"Non hai ancora premuto"</span>))
  }

  num = 0

  <span class="org-variable-name">@bottone</span>.click {
    num += 1
    <span class="org-variable-name">@note</span>.text = <span class="org-string">"Hai premuto "</span> + num.to_s + <span class="org-string">" volte"</span>
  }

}
</pre>
</div>

<p>
Se salvate come <i>scarpe11.rb</i> ed eseguite, vedrete che vi comunicherà il numero delle volte che avete premuto il bottone.
</p>

<p>
Adesso riprendiamo del codice che avevamo già scritto, le nostre <i>tabelline</i>:
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-type">Shoes</span>.app(<span class="org-constant">title</span>: <span class="org-string">"la tabellina"</span>, <span class="org-constant">width</span>: 340, <span class="org-constant">height</span>: 280) {

<span class="org-keyword">def</span> <span class="org-function-name">tabellina</span>
  numeri = [1,2,3,4,5,6,7,8,9,10]
  (numeri.map { |numero|
          (numeri.map { |moltiplicatore|
             valore = numero * moltiplicatore
            (valore &lt; 10 ? <span class="org-string">'0'</span> : <span class="org-string">''</span>) + valore.to_s + <span class="org-string">' | '</span>
          }).join
        }).join(<span class="org-string">"\n"</span>)
 <span class="org-keyword">end</span>

  stack(<span class="org-constant">margin</span>: 10) {
    <span class="org-variable-name">@tabellina</span> = para(strong(tabellina))
    <span class="org-variable-name">@tabellina</span>.style(<span class="org-constant">fill</span>: red, <span class="org-constant">stroke</span>: white)
  }

}
</pre>
</div>

<p>
Scrivete, salvate come <i>scarpe12.rb</i> ed eseguite.
Qui ho usato anche il metodo <i>style</i> per colorare il paragrafo: di rosso lo sfondo e bianco il testo.
</p>

<p>
Adesso rifacciamola ancora, un po' meglio (forse).
</p>

<div class="org-src-container">

<pre class="src src-ruby"><span class="org-type">Shoes</span>.app(<span class="org-constant">title</span>: <span class="org-string">"la tabellina"</span>, <span class="org-constant">width</span>: 412, <span class="org-constant">height</span>: 412, <span class="org-constant">resizable</span>: <span class="org-variable-name">true</span>) {

  <span class="org-keyword">def</span> <span class="org-function-name">tabellina</span>
    numeri = [1,2,3,4,5,6,7,8,9,10]
    numeri.map { |numero|
      numeri.map { |moltiplicatore|
        numero * moltiplicatore
      }
    }
  <span class="org-keyword">end</span>

  width = 40
  height = 40
  top = 0

  tabellina.each_index { |numero_riga|
    stack(<span class="org-constant">margin_left</span>: 2) { 
      flow {
        left = 0        
        tabellina[numero_riga].each_index { |numero_colonna|
          valore =  tabellina[numero_riga][numero_colonna]
          pad = <span class="org-keyword">if</span> valore &lt; 10
                  <span class="org-string">'  '</span>
                <span class="org-keyword">elsif</span> valore &gt;= 10 &amp;&amp; valore &lt; 100
                  <span class="org-string">' '</span>
                <span class="org-keyword">else</span>
                  <span class="org-string">''</span>
                <span class="org-keyword">end</span>          
          button = button(valore.to_s + <span class="org-string">' '</span>)
          button.style(<span class="org-constant">top</span>: top, <span class="org-constant">left</span>: left, <span class="org-constant">width</span>: width, <span class="org-constant">height</span>: height)
          button.instance_variable_set(<span class="org-constant">:@coord</span>, [numero_riga + 1, numero_colonna + 1])
          button.click { |btn|
            coord = btn.instance_variable_get(<span class="org-constant">:@coord</span>)      
            alert(<span class="org-string">"Si ottiene moltiplicando </span><span class="org-variable-name">#{ coord.join(' x ')}</span><span class="org-string">, oppure </span><span class="org-variable-name">#{ coord.reverse.join(' x ')}</span><span class="org-string">"</span>)
          }

          left += width + 1
        }
      }
      top += height + 1
    }
  }
}
</pre>
</div>

<p>
Salvate come <i>scarpe13.rb</i> ed eseguite.
</p>

<p>
Qui ho usato anche delle caratteristiche particolari di Ruby, la sua dinamicità. Ho creato una variabile di istanza mentre il programma funziona. Può sembrare <i>normale</i>, ma vi assicuro che non lo è nei linguaggi di programmazione. 
Ruby, per questo (ma ce ne sono anche altri) è considerato un linguaggio <i>dinamico</i>.
Con il metodo <i>instance_variable_set</i> ho impostato la variabile ed il suo valore mentre con <i>instance_variable_get</i> l'ho letto in seguito.
</p>

<p>
Si possono fare molte cose con le caratteristiche <i>dinamiche</i>, come per esempio creare al volo metodi, o eliminarli da una istanza.
</p>

<p>
Guardate come una espressione <i>if..else..end</i> restituisca un valore e per questo la chiamo <i>espressione</i>. Guardate come si possono fare test multipli con la sintassi <i>elsif</i> che sta per <i>else if</i>. 
</p>

<p>
Con questo esempio abbiamo concluso questa superficiale panoramica su <i>Shoes</i> e vi rimando al sito ufficiale per imparare ulteriormente.
</p>

<p>
<i>Shoes</i> è decisamente lenta, ve ne sarete accorti, ma era nata per una scopo bene preciso che non è ovviamente quello di creare applicazioni complesse. È interessante per imparare alcune delle regole base della programmazione ad eventi per le interfacce grafiche; le cose più serie sono possibili anche  in Ruby, ma bisogna andare su librerie notevolmente più complesse.
</p>
</div>
</div>
</div>
</div>
</div>


<div id="outline-container-sec-3-6" class="outline-3">
<h3 id="sec-3-6"><span class="section-number-3">3.6</span> Conclusioni</h3>
<div class="outline-text-3" id="text-3-6">
<p>
Abbiamo solo grattato la superficie e spero di avervi almeno fatto venire la <i>curiosità</i> su cosa voglia dire programmare. Ora qui, abbiamo terminato.
</p>

<p>
Vi rimando alla documentazione ufficiale dove troverete molte cose interessanti: <a href="http://www.ruby-doc.org/">http://www.ruby-doc.org/</a>
</p>

<p>
<b>Ruby</b> è un linguaggio potente, adatto a molteplici usi. Se vogliamo trovare un difetto è che <i>non è veloce</i>, anche se nelle varie versioni lo è sempre di più.
</p>

<p>
Ruby ha caratteristiche che non fanno rimpiangere quello, perché rende programmare <i>divertente</i> e <i>produttivi fin da subito</i> il che non è niente male.
</p>

<p>
Potete fare della <i>Metaprogrammazione</i> per esempio e fare cose davvero <i>magiche</i>. 
Potete creare metodi <i>al volo</i> mentre il programma sta funzionando, estendere classi esistenti senza derivarle. Modificare comportamenti prefissati. <br >
</p>

<p>
Il limite è davvero <i>solo la fantasia</i>. <br >
</p>

<p>
Vorrei ringraziare Yukihiro Matsumoto, per averlo pensato ed inizialmente creato ed aver aperto le porte ad una selva di programmatori contenti e rilassati. <br >
</p>

<p>
Lo dico molto spesso, <b>Ruby è magico e divertente</b>. <br >
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Data: 2014-10-21</p>
<p class="author">Autore: Massimo Maria Ghisalberti - pragmas.org</p>
<p class="date">Created: 2014-11-02 dom 15:38</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.4.51.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
